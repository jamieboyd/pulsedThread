<!DOCTYPE html>
<HTML>
<head>
<title>pulsedThread</title>
<META NAME="AUTHOR" CONTENT="Jamie Boyd">
</head>
<H1>Documentation for pulsedThread</H1>
<p>PulsedThread uses the <a href = "http://pubs.opengroup.org/onlinepubs/7908799/xsh/pthread.h.html">POSIX pthread library</a> to set up and control a threaded task for precise, independent timing of events that can be categorized as pulses or trains of pulses. PulsedThread uses a mix of C++ class methods and C-style functions and structures to use the pthread C library with the convenience of C++ classes. For C++ programmers, the pulsedThread class methods wrap up all the pthread calls so that use of the pulsedThread class from your own C++ code requires no knowledge of the pthread library, and only limited knowledge of the C-style structures and functions used by pulsedThread. You will need to know C-style function references and void pointers.</p>

</p>Under the hood, a pulsedThread object uses Pthread library functions to start and control a separate thread, running <a href= "#pulsedThreadFunc"><b>pulsedThreadFunc</b></a>. The Pthread running pulsedThreadFunc controls all of the pulse timing, and calls user-supplied functions with user-supplied data at the starts of the high and low periods of each pulse.  Each pulsedThread object has a <a href= "#taskParams_Struct"><b>taskParams structure</b></a> that both it and its associated pthread can access, containing function references to the user-supplied functions and data and pulse timing information. The pulsedThread object communicates with its associated Pthread through this taskParams structure: configuring pulse timing and number; telling the pthread to do pulses or trains; perhaps getting results back from the pthread.</p> 

<p>The PulsedThread project also contains code for making <a href = "https://docs.python.org/3.5/extending/building.html"><b>Python C-modules</b></a> that can create and control pulsedThread objects from Python. Some simple examples making Python C-modules using pulsedThread are included.</p>

<p>PulsedThread was originally written to control Raspberry Pi GPIO hardware. The <a href= "https://github.com/jamieboyd/GPIO_Thread">GPIO_Thread</a> project uses the pulsedThread project to make C++ classes and Python C-modules that output independently timed pulses or trains of pulses on standard GPIO pins, including running a 2-phase stepper motor, and to output wave forms or control a servo-motor using the PWM peripheral.</p>

<h2>Installing the pulsedThread Library</h2>
Making the C++ library is done with the provided make file
<dl>
	<dt>make</dt>
	<dd>compiles the library</dd>
	<dt>sudo make install</dt>
	<dd>copies the compiled library to usual places and also copies the header files pulsedThread.h and pyPulsedThread.h to the usual place.</dd>
	<td>make greeter</td>
	<dd>compiles the Greeter application, by running the compiler command: g++ -O3 -std=gnu++11 -lpulsedThread Greeter.cpp -o Greeter</dd>
	<td>make minimalGreeter</td>
	<dd>compiles the MinimalGreeter application, by running the compiler command: g++ -O3 -std=gnu++11 -lpulsedThread minimalGreeter.cpp -o MinimalGreeter</dd>
</dl>
Make sure to run make install before running make greeter or make minimalGreeter.

<h2>Table of Contents</h2>
<ol>
	<li><a href = "#LIST_OF_FILES">List of Files</a></li>
	<li><a href="#Pulsed_Thread_Events">Pulsed Thread Events And Timing</a></li>
	<li><a href = "#Task_Functions_and_Data">User-supplied Task Functions and Data</a></li>
	<li>The pulsedThread Class</a>
	<ol>
		<li><a href = "#Constructors">Constructors</a></li>
		<li><a href = "#Running_A_Thread">Running Pulsed Thread Tasks</a></li>
		<li><a href= "#Changing_Pulse_Timing">Changing Pulse Number and Timing</a></li>
		<li><a href= "#Using_endFuncs">Using End Functions</a></li>
		<li><a href= "#Modifying_Custom_Data">Modifying Custom Data</a></li>
		<li><a href="#Array_EndFuncs">Special Support for endFuncs that Iterate through an Array</a></li>
	</ol>
	</li>
	<li><a href="#Minimal_Application">A Minimal Application Example</a></li>
	<li><a href = "#Minimaller_App">An Even More Minimal Application Example</a></li>
	<li><a href = "#GPIO_App">End-Function Application Example with GPIO</a></li>
	
	<li>About the Pthread</li>
	<ol>
		<li><a href= "#pulsedThreadFunc">pulsedThreadFunc function</a></li>
		<li><a href= "#taskParams_Struct">the taskParams structure</a></li>
		<li><a href = "#Timing_Utilities">Timing Utilities</a></li>
	</ol>
	
	
	<li><a href = "#Python_C_Module">Using pulsedThread in a Python C++ Module</a></li>
	
</ol>

<a name="LIST_OF_FILES"><h2>List of Files</h2></a>
<dl>
	<dt>pulsedThread (pulsedThread.cpp, pulsedThread.h)</dt>
	<dd>- Contains the pulsedThread C++ class that starts and controls a pthread, the C-style function run by the pthread, and the data structure that the pulsedThread object and associated pthread share.  pulsedThread.h also contains some utility functions for setting and configuring timers using system time functions and some constants whose uses are described below.</dd>
	<dt>Greeter (Greeter.h, Greeter.cpp) and MinimalGreeter (minimalGreeter.cpp)</dt>
	<dd>- Make simple C++ test programs that use the pulsedThread class.  They simply print messages to the command line</dd>
	<dt>pyPulsedThread.h </dt>
	<dd>- Contains a collection of functions for controlling a pulsedThread object wrapped in a PyCapsule, with wrappers for many pulsedThread functions.  It is useful for building Python C-modules controlling pulsedThread objects.</dd>
	<dt>makefile</dt>
	<dd>- Make file that compiles and installs pulsedThread as a C++ library, copies pulsedThread.h and pyPulsedThread.h to system library directories, and optionaly compiles Greeter or MinimalGreeter.</dd>
	<dt>pyGreeter.cpp</dt>
	<dd>- Describes a simple Python C-module, ptGreeter, that uses the pulsedThread library and the code from Greeter.cpp with functions from pyPulsedThread.h to make a Python C-module that prints messages from a pulsedThread object.</dd>
	<dt>setup_ptGreeter.py</dt>
	<dd>- Setup code to compile the ptGreeter C module. Run: python3 setup_ptGreeter.py build_ext --inplace. </dd>
	<dt>PTGreeter.py</dt>
	<dd>- Makes a Python wrapper providing a "Pythonic" object interface to ptGreeter. Run from command line, not IDLE, as python3 PTGreeter.py to see independent output from  Python and C++ object.</dd>
	<dt>pyPTpyFuncs.cpp</dt>
	<dd>- Uses code from PyPulsedThread.h to make a Python C-module, ptPyFuncs, that runs callbacks for the high and low functions from a user-provided Python object.</dd>
	<dt>setup_pyPTpyFuncs.py</dt>
	<dd>- Setup code to compile the ptPyFuncs C module. Run: python3 setup_setup_pyPTpyFuncs.py install</dd>
	<dt>PTpyGreeter.py</dt>
	<dd>- Uses ptPyFuncs in a Python class whose HiFunc and LoFunc simply print hellos and good byes. All printing is done from Python, so it can be run form IDLE.</dd>
	<dt>PTpyGPIOTrain.py</dt>
	<dd>- For Raspberry Pi only, uses ptPyFuncs in a Python class whose HiFunc and LoFunc use RPi.GPIO to make a train of pulses on a GPIO pin with pulse width modulation.</dd>
</dl>


<a NAME="Pulsed_Thread_Events"><h2>PulsedThread Events and Timing</h2></a>
Each pulsedThread object starts a pthread that runs a function, pulsedThreadFunc, that controls periodic timing of events in a pulsed fashion; a "set high" event happens at the start of each pulse and a "set low" event happens after the pulse duration, with a delay between pulses. You define pulse duration and delay, the number of pulses, and the set high and set low events. The high and low events are defined by function calls; each pulsedThread object is initialized with a pair of function pointers for the functions that are called on the "High" and "Low" events (referred to as HiFunc and LoFunc). These function pointers, as well as pointers to all needed data, is stored in a taskParams structure accessed by both the pulsedThread object and the pthread running pulsedThreadFunc.</p>

<p>Three types of events are supported: single pulses, trains of a defined number of pulses, and infinite trains of an unlimited number of pulses. These three types are coded as integers, and have defined constants for ease of use.
<table cellspacing="0" cellpadding="0" border = "1">
	<caption>Three Types of pulsedThread Events</caption>
<tbody>
	<tr>
		<td>Constant</td>
		<td>Value</td>
		<td>Meaning</td>
	</tr>
	<tr>
		<td>const int kPULSE</td>
		<td>1</td>
		<td>Waits for delay, calls HiFunc, waits for duration, calls LoFunc</td>
	</tr>
	<tr>
		<td>const int kTRAIN</td>
		<td>2</td>
		<td>Calls hiFunc, waits for duration, if Delay > 0, calls loFunc and waits for delay, repeats for set number of Pulses</td>
	</tr>
	<td>const int kINFINITETRAIN</td>
	<td>0</td>
	<td>Calls hiFunc, waits for duration, calls loFunc and waits for delay, repeats until requested to stop</td>
</tr>
</tbody>
</table>
A single pulse waits for the delay, runs the HiFunc, then waits for the duration, and runs the LowFunc. You need to initialize a pulse in the low state.  Remember that "high"and "low" are notional, not actual descriptions, so programming a high-to-low pulse is as simple as swapping the hiFunc with the loFunc.  A train repeatedly runs the HiFunc and waits for the duration, then runs the LowFunc and waits for the delay, repeating for a defined number of pulses. An infinite train has no set number of pulses, but can be stopped and restarted arbitrarily. </p>

<p>Pulse timing is controlled with the system microsecond timer and the nanosleep function. Three methods of timing are provided, of increasing accuracy and processor use. The first method is for the pthread to sleep for the entire time of a pulse duration. This method requires the least amount of processor time, but it ignores both the time it takes for the Hi and Lo functions to run, and the non-zero, and variable, time that it takes for a sleeping pthread to wake.  There is a lower limit on how long a pthread can sleep; calling for shorter sleeps will give sleeps no shorter than this limit. In fact, sleep is guaranteed to sleep a pthread for <b>at least</b> as long as requested, but may sleep it for longer than requested, sometimes much longer, depending on thread scheduling by the operating system.  Nonetheless, this may be accurate enough for many purposes, at relatively lower frequencies, and with short, constant duration tasks.  A more accurate but more processor intensive method is for the pthread to calculate and record the end time of each duration, sleep for the requested duration minus some small constant time, and upon awakening, repeatedly check the time in a tight loop until the duration has ended. For durations smaller than this constant time, the pthread is not slept at all, but goes directly to spinning.  For Hi and Lo events that may take long relative to pulse timing, or be of variable duration, a third timing method is available that calculates the sleep period needed for each duration to keep the pthread on schedule, and can countermand sleeping if a pthread is running behind. This method can not completely eliminate jitter, but will keep the average frequency remakably constant.  These three methods are coded as integers, and have constants defined that can be used, for instance, in the pulsedThread constructors:
<table cellspacing="0" cellpadding="0" border = "1">
	<caption>Three Modes of pulsedThread Timing</caption>
<tbody>
	<tr>
		<td>Constant</td>
		<td>Value</td>
		<td>Meaning</td>
	</tr>
	<tr>
		<td>const int ACC_MODE_SLEEPS</td>
		<td>0</td>
		<td>Thread sleeps for defined duration of period</td>
	</tr>
	<tr>
		<td>const int ACC_MODE_SLEEPS_AND_SPINS</td>
		<td>1</td>
		<td>Thread sleeps for period - kSLEEPTURNAROUND microseconds,then spins for remaining time</td>
	</tr>
	<tr>
		<td>const int ACC_MODE_SLEEPS_AND_OR_SPINS</td>
		<td>2</td>
		<td>Sleep time is re-calculated for each duration, sleep is countermanded if pthread is running late</td>
	</tr>
	</tbody>
</table>

A constant, kSLEEPTURNAROUND,  defines how long, in microseconds, we aim to spin at the end of pulse timing in the second and third accuracy levels. The default value is 200 microseconds. Making this time longer may improve accuracy; making it shorter will decrease processor usage. If you change the constant, you will need to recompile the pulsedThread library. </p>

<a NAME = "Task_Functions_and_Data"><h2>User-supplied Task Functions and Data</h2></a>
<p>The job of a pulsedThread is the timing of the setHigh and setLow events of some pulsed task, but what that task is, and what those events do, is is up to you. This flexibility is provided by function references to functions that take a single void pointer; your own functions are called with your own data.
<dl>
	<dt>void (*gHiFunc)(void * volatile)</dt>
	<dd>user-provided function that is called at the start of the high period of each pulse. The void pointer points to user's custom data.</dd>
	<dt>void (*gLoFunc)(void * volatile)</dt>
	<dd>user-provided function that is called at the start of the low period of each pulse. The void pointer points to user's custom data.</dd>
</dl>
You need to write at least one function with the above signature, and pass the address of that function to the pulsedThread. </p>

<p>When the pulsedThreadFunc calls your hiFunc or loFunc, the void pointer will point to your custom data. You must have previously created this data and passed a pointer to it to the pulsedThread. Your hiFunc and loFunc must first cast the void pointer to a pointer of the correct type before accessing your data. Your data can be anything from a single integer to a custom-defined structure that holds many fields of different types. Your hiFunc and loFunc can read and write to your custom data. The pulsedThread object can also read and write to your custom data. The pulsedThread class methods and the pulsedThreadFunc run by its associated  pthread use a mutual exclusion variable (pthread_mutex_t type) to prevent modifying the data at the same time. Some of the pulsedThread class methods have an optional variable to lock this mutex before modifying the pthread data, which cna be set if the method is called when the pthread is running its task. The principle of passing both functions and data to the pthread is also used for modifying pthread data after a pthread is created. The functions passed to the pthread for the pthread to call are referred to as call-backs.</p>

<h2>The PulsedThread Class</h2>
<a NAME="Constructors"><h3>Constructors</h3></a>
<p>There are two constructors for the pulsedThread class, one sets initial pthread timing based on integer numbers of microseconds for delay, duration, and number of pulses. The other sets pulse timing based on floating point values for frequency (Hz), duty cycle (0 to 1), and train duration (seconds).  Each integer specified timing has a unique floating point representation, and vice versa, within the extent of rounding errors. Saving timing information in both formats in the taskParams structure is redundant, but allows easy conversions between the two modes of description. The ticks2times and times2ticks utility functions are used to convert between the two formats. The remaining six parameters are the same for both constructors, concering the hiFunc and loFunc, and the data for them to use.</p>

<p>The pulsedThread user needs to supply the loFunc and hiFunc run by the thread, and task data for the hiFunc and loFunc to operate on. The <b>taskParams</b> structure contains a field for a pointer to taskData, for data specific to that particular pulsedThread object. This way, different pulsedThread objects can be running the same set of hiFunc and loFunc, but using different data (e.g., GPIO pin numbers). The taskData is initialized by the pulsedThread constructor with data from the initData parameter, a void pointer to the initialization data created by the user.  If no user-supplied call-back is provided (initFunc is a nullptr), then the taskData pointer in the taskParams struct is simply set to the initData pointer.  In this case, the initData becomes the taskData, and the user must make sure the initData pointer remains valid for the life of the pulsedThread object. If an initFunc <b>is</b> provided, then it is called with a void pointer to initData, and a by-reference void pointer to the taskData pointer in the taskParams struct: <br>int (*)(void *, void * &amp;)<br>and is called in the constructor like this:<br>errCode =initFunc(initData , theTask.taskData);<br>The initFunc can allocate the taskData pointer to whatever memory it needs, and copy over data from the initData. In this way, the user does not need to keep track of the initData, making sure that it is or modified or deleted when the pthread still needs it.
<ul>
<li>pulsedThread::pulsedThread (unsigned int gDelay, unsigned int gDur, unsigned int gPulses, void *initData, int (*initFunc)(void *, void * volatile &amp;), void (*gLoFunc)(void * volatile), void (*gHiFunc)(void * volatile),int gAccLevel,int &amp;errCode)
<br>(first 3 params using Integer values - make sure to cast all 3 parameters to unsigned int)</li>
<li><ol><li>unsigned int gDelay - for a single pulse, delay until HiFunc runs, in microseconds. For trains, duration between LoFunc and HiFunc</li>
<li>unsigned int gDur - for a single pulse, duration between HiFunc and LoFunc that ends the pulse. For trains, duration between HiFunc and LoFunc</li>
<li>unsigned int gPulses - 1 to make a pulse, 2 or greater to indicate the number of pulses in a train, or 0 to make an infinite train</li></ol><br></li>
<li>pulsedThread::pulsedThread (float gFrequency, float gDutyCycle, float gTrainDuration , void *initData, int (*initFunc)(void *, void * volatile &amp;), void (*gLoFunc)(void * volatile), void (*gHiFunc)(void * volatile),int gAccLevel,int &amp;errCode)<br>(first 3 params using floating point values - make sure to cast all 3 parameters to float)</li>
<li><ol><li>float gFrequency - pulse frequency in Hz</li>
<li>float gDutyCycle - pulse duty cycle, from 0 &lt; duty cycle &lt;= 1</li>
<li>float gTrainDuration - duration of the train, in seconds. set to 0 for infinite train, set to length of one pulse for a single pulse</li></ol><br>
(Rest of the parameters, same for both constructors)</li>
<li><ol start = "4"><li>void *initData - pointer to whatever data you want to use when initializing the pulsedThread object.</li>
<li>int (*initFunc)(void *, void * volatile &amp;) - function pointer for initialization function, or nullptr if no special initialization function is provided</li>
<li>void (*gLoFunc)(void * volatile) - Your LoFunc is run on high to low transitions. It gets passed a pointer to the taskCustomData you initialized</li>
<li>void (*gHiFunc)(void * volatile) - Your HiFunc is run on low to high transitions. It gets passed a pointer tothe taskCustomData you initialized</li>
<li>int gAccLevel - sets the method that the pthread uses to control pulse timing.</li>
<li>int &amp;errCode - reference variable that is set to 0 if no error during pulsedThread creation, else set to non-zero</li></ol>
</ul></p>

<p>The flipside of a constructor is a destructor. The pulsedThread destructor stops the pthread from running and then destroys it. If your initFunc allocates memory, pointed to by the taskData pointer, you will want to delete it when the pulsedThread object is destroyed. The setTaskDataDelFunc method lets you set a function that the pulsedThread destructor will call. You call the method with the address of your custom delete function:<br>
void setTaskDataDelFunc  (void (*delFunc)( void *));<br>
Your custom taskData delete function gets a void pointer pointing to your custom taskData created by your initFunc. Cast it to the appropriate type, and delete your data. You can do any other needed cleanup here as well.</p>

<a NAME="Running_A_Thread"><h3>Running PulsedThread Tasks</h3></a>
Once you have made a pulsedThread object, you tell it to do the pulse or train for which it is configured with a call to class methods DoTask or DoTasks:
<dl>
	<dt>void DoTask (void)</dt>
	<dd>signals the pthread to run the configured task (pulse or train) once</dd>
	<dt>DoTasks(unsigned int nTasks)</dt>
	<dd>signals the pthread to run the configured task nTasks times in a row</dd>
	<dt>void UnDoTasks (void)</dt>
	<dd>removes requested tasks in doTask, save 1</dd>
</dl>
<p>Note that the pthread will be busy for the duration of the task or tasks, but DoTask or DoTasks will return immediately, and the pulsedThread object will be ready to accept other commands. Thus, you can add more task requests while the originals are still being processed.</p>
<p>DoTask increments the doTask field in the taskParams structure shared by the pulsedThread and its pthread. DoTasks will add nTasks to the doTask field. Making doTask non-zero will wake up the pthread and it will perform its task, or tasks. The doTask field in the taskParams structure is an unsigned 32 bit integer, but the 8 upper bits are reserved for signalling events that the pthread has to respond to. This means you can request a maximum of 2<sup>29</sup>-1=536,870,911 tasks.  Finally,  unDoTasks lets you cancel requested tasks except for the train or pulse currently in progress, by setting doTask to 1.</p>

<p>Two special methods, startInfiniteTrain and stopInfinteTrain, are used for starting and stopping infinite trains.
<dl>
	<dt>void startInfiniteTrain (void)</dt>
	<dd>starts a pulsedThread configured as an infinite train</dd>
	<dt>void stopInfinteTrain(void)</dt>
	<dd>stops an infinite train. it can be restarted with startInfiniteTrain without having to reconfigure it.</dd>
</dl></p>

<p>You can ask if the pthread of a pulsedThread is still busy doing a task, or you can wait until a pulsedThreads pthread is done a task:
<dl>
	<dt>int isBusy(void )<dt>
	<dd>returns 0 if its pthread is not currently doing a task, else returns the number of tasks still left to do. An infinite train returns 1 if it is active, 0 if it is not active.</dd>
	<dt>int waitOnBusy(float waitSecs)</dt>
	<dd>does not return until its pthread is no longer busy, or until waitSecs seconds has elapsed, whichever happens first.  The return vlaue is 0 if the pthread finished the tasks before waitSecs, or returns the number of tasks still left to do if the pthread did not finish before the waitSecs timeout expired. Calling waitonBusy for an infinite train is allowed, and will return 1 after waitSecs.<dd>
</dl></p>

<a name = "Changing_Pulse_Timing"><h3>Changing Pulse Number and Timing</h3></a>
<p>There are a number of methods to change the timing of a pulsedThread task after it has already been created. As for creating the pulsedThread, the task modification methods use either integer pulse number and delay/duration microseconds or frequencies, dutycycles, and train durations in floating point values. The integer methods are:
<dl>
	<dt>int modDelay (unsigned int newDelay)</dt>
	<dd>modifies low time of each pulse</dd>
	<dt>int modDur (unsigned int newDurUsecs)</dt>
	<dd>modifies high time of each pulse</dd>
	<dt>int modTrainLength (unsigned int newPulses)</dt>
	<dd>modifies number of pulses in a train. A train must always have at least 2 pulses.</dd>
</dl>
The frequency/dutycycle/train duration modification methods are:
<dl>
	<dt>int modFreq (float newFreq)</dt>
	<dd>changes the frequency of the pulses, in Hz, while keeping duty cycle and train duration (in seconds) constant</dd>
	<dt>int modTrainDur (float newDur)</dt>
	<dd>Changes train duration (in seconds) by changing train length (number of pulses), keeping frequency and dutycycle constant</dd>
	<dt>int modDutyCycle (float newDutyCycle)</dt>
	<dd>Changes the duty cycle of the train, keeping the frequency and the train length constant.</dd>
</dl>
As can be seen, changing one of the integer parameters can change several of the floating point parameters, and changing one of the floating point parameters can change several of the integer parameters. After each modification of timing parameters, one of the ticks2Times or times2Ticks utility functions is called as appropriate to update the other set of parameters. The pulsedThread class has methods for getting the timing parameters, in both formats:
<dl>
	<dt>unsigned int getNpulses (void)</dt>
	<dd>returns 0 for an infinite train, the number of pulses in a finite train, or 1 for a single pulse</dd>
	<dt>int getpulseDurUsecs (void)</dt>
	<dd>returns pulse duration (HI time) in microseconds</dd>
	<dt>int getpulseDelayUsecs (void) - returns pulse delay (LO time) in microseconds
	<dt>getTrainDuration (void)</dt>
	<dd>returns train duration in seconds</dd>
	<dt>getTrainFrequency (void)</dt>
	<dd>returns train frequency in Hz</dd>
	<dt>getTrainDutyCycle (void)</dt>
	<dd>returns train duty cycle (0 -1)</dd>
</dl></p>

<p>If the pthread is running (taskParams.doTask > 0) when the pulsedThread function to modify pulse timing is called, the pulsedThreadFunc will modify the task after the current pulse or train is completed, so pulse paramaters are never changed in the middle of a pulse. For an infinite train, the pulsedThreadFunc looks for and applies any timing modifications after each current pulse.</p>

<a name= "Using_endFuncs"><h3>Using End-Functions</h3></a>
<p>An end-function, or endFunc, is another function you supply, like the hiFunc and loFunc functions. The optional endFunc is called only at the end of a task, i.e., at the end of a train, at the end of a single pulse, or at the end of each pulse in an infinite train. This is most useful for a train where you want to change some aspect of the train at the end of each train, but not after every pulse in the train. Typically, this would include changing frequency or duty cyle for pulse width modulation. Complex endFuncs may require custom data, such as an array of pre-calculated duty cycle values for pulse width modulation. The taskParams structure includes a void pointer for custom data for endFuncs:<br>
void * endFuncData;<br>
If your endFunc needs custom data, You allocate it using the methods described in <a href= "#Modifying_Custom_Data">Modifying Custom Data and Functions</a>. SImilarly for taskData, you can set a function to delete you custom endFunc data when thge pulsedThread object is about to be deleted. Your endFunc is passed a void pointer to your custom endFuncdata, plus, for added flexibility, a pointer to the entire taskParams structure.
<dl>
	<dt>void setEndFunc (void (*endFunc)(void *, taskParams *))</dt>
	<dd>Sets the endFunc pointer in taskParams structure to the address of your function<dd>
	<dt>void unSetEndFunc (void)</dt>
	<dd>Sets the endFunc pointer in taskData structure to nullptr</dd>
	<dt>int hasEndFunc (void</dt>
	<dd>returns 1 if an endFunc is currently installed, else 0 if endFunc pointer in taskData structure is nullptr</dd>
	<dt>void setEndFuncDataDelFunc  (void (*delFunc)( void *))</dt>
	<dd>sets a function that will be run with a void pointer to your endFunc data when a pulsedThread is about to be killed</dd>
</dl>
Note that unSetEndFunc loses the reference to endFunc; there is no corresponding reSetEndFunc that could re-enable the endFunc without calling setEndFunc with the address of your function.</p>

<a name= "Modifying_Custom_Data"><h3>Modifying Custom Data</h3></a>
<p>After creating a pulsedThread, you may wish to change the custom data referenced by the taskData pointer.  You might also wish to add data for an endFunc, which also has a pointer in the taskParams struct. Those data are not something we want to be easily modified, because they are shared between the pulsedThread object and its Pthread. The modCustom method can be used with the isLocking parameter to modify taskData and endFuncData in a thread-safe way. You pass modCustom a pointer to your data modification function (modFunc) and a pointer to the data for your modfunc to use. If isLocking is set, modCustom copies the data and function pointers into the taskParams structure and sets a flag to alert the Pthread. The Pthread will run the modfunc when it is not actively doing a task. This way, data will not be changed in the middle of a pulse or train. When the pthread has run the modfunc, it resets the flag. The getModCustomStatus method can be used to see if your modfunc has run. Do not delete the modData that you passed to modCustom until the function has run. You can get a pointer to your customData in taskData with getCustomData, through which you can read and even modify the taskData directly. You can also use this pointer to delete your custom data just before you kill the thread. A better method is to supply a function to delete your custom data, and then the pulsedThread destructor will run your delCustomData function (with a pointer to your custom data) in its own destructor. Method for modifying custom data:</p>
<dl>
<dt>int modCustom (int (*modFunc)(void *, taskParams *), void * modData, int isLocking)</dt>
<dd>- modifies taskData or endFuncData using your provided modFunc and pointer to your modification data, with thread-safe locking option. The parameters are:
	<dl>
		<dt>int (*modFunc)(void *, taskParams * )</dt><dd>a pointer to a function that takes 2 parameters,
			<ol><li>a pointer to your input data</li>
			<li>a pointer to the taskParams structure</li>
			</ol></dd>
	<dt>void * modData</dt>
	<dd>- a pointer to whatever data you want the modFunc to use</dd>
	<dt>int isLocking</dt><dd> flag to indicate if you want to wait for pthread to finish a task. You can set this to 0 IF you are absolutely sure the pthread will not be accessing the custom data</dd></dl></dd>
<dt>int getModCustomStatus (void)</dt>
<dd>Returns 1 if the pulsedThread object is waiting for the pThread to run the modData function, else 0</dd>
<dt>void * getTaskData (void)</dt>
<dd>Returns the pulsedThread's taskData pointer. Can be used to read or write the taskData directly. Be careful.</dd>
<dt>void * getEndFuncData (void)</dt>
<dd>returns a pointer to the endFunc data for the task</dd>
<dt>void getTaskMutex (void)</dt>
<dd>calls Pthread function to lock the shared taskParams data so the Pthread can not access it. For modifying data through pointer obtained with  getTaskData or getEndFuncData</dd>
<dt>void giveUpTaskMutex (void)</dt>
<dd>releases the lock on taskParams.
<dd></dd>
</dl>

<p>You can also change the hiFunc and loFunc functions by changing the function pointers stored in the taskParams structure using the following methods:
<dl>
	<dt>setLowFunc (void (*loFunc)(void * volatile))</dt>
	<dd>sets function to run for Lo events</dd>
	<dt>setHighFunc (void (*hiFunc)(void * volatile))</dt>
	<dd>sets function to run for Hi events</dd>
</dl>

<a name = "Array_EndFuncs"><h3>Special Support for endFuncs that Iterate through an Array</h3></a>
<p>Two endFuncs are provided that change either or frequency or duty cycle by cycling through an array of floating point values. because this is a common use of an end function, support for changing frequency and duty cycle is built right into the pulsedThread class. Both endFuncs are designed to work with the same custom struct, provided in pulsedThread.h:</p>
<pre>
/* ******************* A Custom struct for endFunc Data using an array **************************
for the two provided endFuncs that change frequency and dutyCycle for trains */
typedef struct pulsedThreadArrayStruct{
	float * arrayData;		// pointer to an array of floats
	unsigned int startPos; 		// where to start in the array when out putting data
	unsigned int endPos;		// where to end in the array
	unsigned int arrayPos;		// current position in array, as it is iterated through
}pulsedThreadArrayStruct, *pulsedThreadArrayStructPtr;
</pre>

<p>The two endFuncs are:<br>
void pulsedThreadFreqFromArrayEndFunc (void * endFuncData, taskParams * theTask);<br>
void pulsedThreadDutyCycleFromArrayEndFunc (void * endFuncData, taskParams * theTask);<br>
The first sets thread frequency, and the second sets thread duty cycle. The endfuncs
<ol>
	<li>cast endFunc data pointer to pulsedThreadArrayStructPtr</li>
	<li>move arrayPos to next point in array and wrap position to start if needed</li>
	<li>use times2Ticks or ticks2Times utility functions to update taskParams with new timing values calculated from array value for frequency or duty cycle</li>
	<li>set high order signal bits of doTask to signal thread that pulse duration and delay have changed</li>
</ol></p>

<p>The arrayData is provided by the user. A callback designed to be used with pulsedThread::modCustom, pulsedThreadSetUpArrayCallback, can be used to copy a pointer to the user's arrayData to the arrayData pointer in the pulsedThreadArrayStruct. <br>
int pulsedThreadSetUpArrayCallback (void * modData, taskParams * theTask);<br>
The modData is a pulsedThreadArrayStruct, same  as is used by the endFunc itself. pulsedThreadSetUpArrayCallback does the following:
<ol>
	<li>cast modData to a pulsedThreadArrayStructPtr</li>
	<li>make a new pulsedThreadArrayStruct , and point endFuncDataPtr at it</li>
	<li>copy over the data from modData, Don't copy array data, just a pointer to the array.</li>
	<li>delete modData</li>
</ol>
Note that the arrayData array itself is not copied, so the user must take care to keep the arrayData from being deleted. The startPos, endPos, and arrayPos are copied into new pulsedThreadArrayStruct. A class method is available that calls modCustom for you. This and other class methods for dealing with array endFuncs are:
<dl>
	<dt>int setUpEndFuncArray (float * newData, unsigned int nData, int isLocking)</dt>
	<dd>sets up a new pulsedThreadArrayStruct as endFunc data to cycle through the provided array of floats</dd>
	<dt>void chooseArrayEndFunc (int endFuncMode)</dt>
	<dd>sets an endFunc to cycle through an array. endFuncMode is 0 for frequency from array, 1 for dutyCycle from array</dd>
	<dt>int setEndFuncArrayLimits (unsigned int startPosP, unsigned int endPosP, int isLocking)</dt>
	<dd>sets starting and ending position within the array, so you can cycle through a subset of the array</dd>
	<dt>int setEndFuncArrayPos (unsigned int arrayPosP, int isLocking)</dt>
	<dd>sets current position within the array, so you can jump immediately to a different part of the array and continue iterating from there</dd>
	<dt>static int cosineDutyCycleArray  (float * arrayData, unsigned int arraySize, unsigned int period, float offset, float scaling)</dt>
	<dd>Utility function to fill a passed-in array with a cosine</dd>
</dl>


<a name="Minimal_Application"><h2>A Minimal Application Example</h2></a>
<p>The file Greeter.cpp contains code for a small test application that demonstrates making and using a pulsedThread object with hiFunc and lowFunc that simply print some information. Aside from main, Greeter.cpp contains the HI, LO, and INIT functions, and the definition of a structure to hold the custom data:</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pulsedThread.h&gt;
#include "Greeter.h"

/*************************************Initialization function*******************************************************
This function initializes the custom data the pthread will need. Previously, we made and filled a ptTestStruct
structure initDataP and passed it to the pulsedThread construtor  (in main).
Here we make an initialization */
int ptTest_Init (void * initDataP, void * &amp;taskDataP){

	// initDataP is a pointer to our custom data structure, so cast it to that
	ptTestStructPtr initData = (ptTestStructPtr) initDataP;
	// task data pointer is a void pointer that points to the taskCustomData field in the taskParams struct
	// It needs to be initialized to a pointer to ptTestStruct 
	taskDataP = new ptTestStruct;
	// make a local ptTestStructPtr  so we don't have to keep casting taskDataP each time we use it
	ptTestStructPtr taskCustomData  =(ptTestStructPtr) taskDataP;
	// copy over name from initialization struct
	int iPos;
	for (iPos=0; iPos &lt; 255 &amp;&amp; initData->name[iPos] != 0; iPos+=1){
		taskCustomData->name[iPos] = initData->name[iPos] ;
	}
	taskCustomData->name[iPos] =0;
	// set times to 0  at start
	taskCustomData->times = 0;
	return 0;
}

/****************************************High and Low functions*********************************************************/
void ptTest_Hi (void * taskData){
// cast task data to our custom struct
	ptTestStructPtr ourData = (ptTestStructPtr) taskData;
	// Print
	if (ourData->times ==0){
		printf ("Hello  from %s\n",  ourData->name);
	}else{
		printf ("Hello again for the %dth time from %s\n",  ourData->times + 1, ourData->name);
	}
}

void ptTest_Lo (void * taskDataP){
	// cast task data to our custom struct
	ptTestStructPtr ourData = (ptTestStructPtr) taskDataP;
	// Print
	if (ourData->times ==0){
		printf ("goodbye  from %s\n",  ourData->name);
	}else{
		printf ("goodbye again for the %dth time from %s\n", ourData->times + 1, ourData->name);
	}
	// only for the low, increment times
	ourData->times +=1;
}

// main function makes a pulsedThread to say hello and goodbye.
int main(int argc, char **argv){
	// make a ptTestStruct to use for iniitialization
	ptTestStruct initStruct;
	initStruct.name [0] = 'P';
	initStruct.name [1] = 'u';
	initStruct.name [2] = 'l';
	initStruct.name [3] = 's';
	initStruct.name [4] = 'e';
	initStruct.name [5] = 'd';
	initStruct.name [6] = ' ';
	initStruct.name [7] = 'T';
	initStruct.name [8] = 'h';
	initStruct.name [9] = 'r';
	initStruct.name [10] = 'e';
	initStruct.name [11] = 'a';
	initStruct.name [12] = 'd';
	initStruct.name [13] = 0;
	// make a pulsedThread with our pttestStruct and our Hi and Lo functions. USe microsecond ddelay, microsecond duration, and number of pulses method
	int errVar;
	pulsedThread * train1 = new pulsedThread ((unsigned int)50000, (unsigned int)50000, (unsigned int)10, (void *) &amp;initStruct, &amp;ptTest_Init, &amp;ptTest_Lo, &amp;ptTest_Hi, ACC_MODE_SLEEPS, errVar);
	if (errVar){
		printf ("Failed to make pulsed thread.\n");
		return 0;
	}
	// let's make another train ,running half the speed of the first one, with a different name 
	// because we copy the array into the custom data sruct, and not just pass a pointer to the array, we can reuse the same array to make second pulsedThread
	initStruct.name [13] = ' ';
	initStruct.name [14] = 'n';
	initStruct.name [15] = 'u';
	initStruct.name [16] = 'm';
	initStruct.name [17] = 'b';
	initStruct.name [18] = 'e';
	initStruct.name [19] = 'r';
	initStruct.name [20] = ' ';
	initStruct.name [21] = 't';
	initStruct.name [22] = 'w';
	initStruct.name [23] = 'o';
	initStruct.name [24] = 0;
	pulsedThread * train2 = new pulsedThread ((unsigned int)100000, (unsigned int)100000, (unsigned int)5, (void *) &amp;initStruct, &amp;ptTest_Init, &amp;ptTest_Lo, &amp;ptTest_Hi, ACC_MODE_SLEEPS, errVar);
	if (errVar){
		printf ("Failed to make second pulsed thread.\n");
		return 0;
	}
	train1->DoTask ();// a train of 10 times should be enough, so just do it once
	train2->DoTask ();
	// show that the train is running on its own
	printf ("Trains were started and should be printing in a second\n");
	// a loop to show we can do real work in the main thread while the pulsedThreads do their own things.
	double aNum=0;
	while (train1->isBusy() &amp;&amp; train2->isBusy()){
		for (float i=0;i &lt; 100000; i+=1){
			aNum += (i*i)/(i+1);
		}
		printf ("Value of busy-work variable calculated to be %.12f\n", aNum);
	}
	printf ("Threads are done printing and so am I\n");
	return 0;
}
</pre>

<p>the main function first makes a ptTestStruct to use for initialization. It is defined in Greeter.h:
<pre>
typedef struct ptTestStruct{
	char name [256];	// name to add to message to print 
	int times;			// track number of times we we have printed it (not used for INIT, only for HI,LO funcs)
}ptTestStruct, *ptTestStructPtr;
</pre>
The ptTestStruct has two fields: a character array to hold the name part of the message to print, and an integer that we use to track the number of times a message is printed. We use the same structure type for initialization of the custom data as we will use for the custom data itself, but that is not generally the case.</p>

<p>Main then calls the pulsedThread constructor with the addresses of the ptTestStruct we just made, and the addresses  of our Hi, Lo, and Init functions, plus timing information on the duration and delay of each pulse (0.5 seconds each), and the number of pulses (a train of 10). Note that we use the integer microsecond delay, microsecond duration, and number of pulses version of the constructor. Also passed to the constructor are a value for pulse timing mode and a pass-by-reference errVar will be set to a non-zero value if the pulsedThread can not be created. The pThread constructor makes a taskParams struct. The constructor calls our INIT function, ptTest_Init, with the pointer to the pttestStruct we passed it, plus a a pointer to the taskCustomData field in the taskParams struct. ptTest_Init initializes the taskCustomData pointer to a new ptTestStruct, initializes the times field of the new pttestStruct to 0, and and copies over the name field from the initialization struct. Finally, the constructor will create the pthread and start the pthread function running, waiting for tasks to be requested.</p>

<p>Main then makes another pulsedThread, requesting another train running half the speed of the first one, and with a different name. Both threads are configured to output a train. Each pulsedThread object sets the doTask variable in its taskParams struct to 1 to signal its pthread to do the train once. The pthread times the pulses and calls the HI and LO functions as appropriate. The HI and LO functions are called with a void pointer to the customData made by the initialization function. The HI and LO functions cast the pointer to a ptTestStructPtr and print a message that contains the name from the character array in the ptTestStruct. The LO function also increments the count in the times field.</p>

<p>After the pulsedThreads are started,  main runs a loop that does some arbitrary calculation and periodically prints the results to show that we can do real work in the main thread while the pthreads run independently. From the loop, we call the isBusy method so we can exit the loop and the program when both pulsedThreads have finished their task.</p>
<h3>Sample ouput from Greeter:</h3>
<pre>
Trains were started and should be printing in a second
Hello  from Pulsed Thread number two
Hello  from Pulsed Thread
Value of busy-work variable calculated to be 4999850021.124797821045
Value of busy-work variable calculated to be 9999700042.249593734741
.
.
.
Value of busy-work variable calculated to be 124996250528.118820190430
Value of busy-work variable calculated to be 129996100549.243515014648
goodbye  from Pulsed Thread number two
Hello again for the 2th time from Pulsed Thread
Value of busy-work variable calculated to be 134995950570.368209838867
.
.
.
Value of busy-work variable calculated to be 369988901563.236572265625
Hello again for the 2th time from Pulsed Thread number two
Hello again for the 3th time from Pulsed Thread
Value of busy-work variable calculated to be 374988751584.361328125000
Value of busy-work variable calculated to be 379988601605.486083984375
.
.
.
Value of busy-work variable calculated to be 2459926210372.271484375000
Value of busy-work variable calculated to be 2464926060393.088867187500
Threads are done printing and so am I
</pre>

<a name = "Minimaller_App"><h2>An Even More Minimal Application Example</h2></a>
The file minimalGreeter.cpp shows the bare minimum of functions needed to use the pulsedThread library, containing a main function that makes a pulsedThread and runs it, a hiFunc, but no loFunc, no initFunc, and no definition of a customData structure.
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pulsedThread.h&gt;

/****************************************High function*********************************************************/
void ptTest_Hi (void * taskData){
	// cast task data to a character array.
	char* name = (char *) taskData;
	// Print hello 
	printf ("Hello  from %s\n",  name);
}

// makes a very minimal pulsedThread to say hello, with no lowFunc, no initFunc, and customData as a simple array, not a structure
int main(int argc, char **argv){
	// make a ptTestStruct to use for initialization
	char name [13];
	name [0] = 'P';
	name [1] = 'u';
	name [2] = 'l';
	name [3] = 's';
	name [4] = 'e';
	name [5] = 'd';
	name [6] = ' ';
	name [7] = 'T';
	name [8] = 'h';
	name [9] = 'r';
	name [10] = 'e';
	name [11] = 'a';
	name [12] = 'd';
	name [13] = 0;
	// make a pulsedThread with our Hi function but no lo func. Value for low time needs to be 0 for this. Use microsecond delay, microsecond duration, and number of pulses method
	int errVar;
	pulsedThread * train1 = new pulsedThread ((unsigned int)0, (unsigned int)5E5, (unsigned int)10, (void *) &amp;name, nullptr, nullptr, &amp;ptTest_Hi, ACC_MODE_SLEEPS, errVar);
	if (errVar){
		printf ("Failed to make pulsed thread.\n");
		return 1;
	}
	// ask the pthread to do a train
	train1->DoTask ();// a train of 10 times should be enough, so just do it once
	// show that the train is running on its own
	printf ("Train was started and should be printing in a second\n");
	// a loop to show we can do real work in the main thread while the pulsedThreads do their own things.
	double aNum=0;
	while (train1->isBusy()){
		for (float i=0;i&lt;100000;i+=1){
			aNum += (i*i)/(i+1);
		}
		printf ("Value of busy-work variable calculated to be %.12f\n", aNum);
	}
	printf ("Thread is done printing and so am I\n");
	return 0;
}</pre>

<h3>Sample output from MinimalGreeter:</h3>
<pre>Train was started and should be printing in a second
Hello  from Pulsed Thread
Value of busy-work variable calculated to be 4999850021.124797821045
Value of busy-work variable calculated to be 9999700042.249593734741
.
.
.
Value of busy-work variable calculated to be 9224723288105.332031250000
Value of busy-work variable calculated to be 9229723138124.140625000000
Hello  from Pulsed Thread
Value of busy-work variable calculated to be 9234722988142.949218750000
Value of busy-work variable calculated to be 9239722838161.757812500000
.
.
.
Value of busy-work variable calculated to be 13089607352644.375000000000
Thread is done printing and so am I
</pre>

<a name = "GPIO_App"><h3>End-Function Application Example with GPIO</h3></a>
<p>Here is a simple application using SimpleGPIO_thread, a sub-class of the pulsedThread class that makes pulses and trains of pulses on a GPIO pin. This program runs an infinite train at 1 kHz. At the end of each pulse, the end-function that changes duty cycle is called. A 100 point array containing a cosine scaled from 0 to 1 provides the dudy cycles.
<pre>
#include "SimpleGPIO_thread.h"
#include <stdio.h>

/* ******************************** makes a GPIO output that does software pulse width modulation *********************************************/
static const int GPIO_PIN = 19;
static const int POLARITY = 0;

int main(int argc, char **argv){
	
	// Use threadMaker function to make a simpleGPIO_thread, an infinite train with frequency = 1kHz, and duty cycle = 0.001
	// SimpleGPIO_threadMaker calls pulsedThread constructor
	SimpleGPIO_thread *  myGPIO= SimpleGPIO_thread::SimpleGPIO_threadMaker (GPIO_PIN, POLARITY, (float)1000,(float)0.001, (float)0, ACC_MODE_SLEEPS_AND_SPINS);
	if (myGPIO == nullptr){
		printf ("SimpleGPIO_thread object was not created. Now exiting...\n");
		return 1;
	}
	// make an array of floats and fill it with values that vary from 0 to 1 in a sinusoidal fashion
	float * endFuncArrayData = new float [100];
	myGPIO->cosineDutyCycleArray (endFuncArrayData, 100, 100, 0.5, 0.5);
	// Set a pointer to this array as endFunc data 
	myGPIO->setUpEndFuncArray (endFuncArrayData, 100, 1);
	// choose the endFunc to modify pulse dutycycle from the array  
	myGPIO->chooseArrayEndFunc (kDUTY_CYCLE);
	// start the train
	myGPIO ->startInfiniteTrain ();
	// let it run for 20 seconds
	myGPIO->waitOnBusy (20);
	// change the part of the array that the endFunc iterates over to the middle part of the array
	int result = myGPIO->setEndFuncArrayLimits (24, 75, 1);
		if (result){
		printf ("setEndFuncArrayLimits reported an error. Now exiting...\n");
		return 1;
	}
	// wait another 20 seconds, then stop the train
	myGPIO->waitOnBusy (20);
	myGPIO->stopInfiniteTrain();
	// clean up, but be sure train is stopped before deleting it
	myGPIO->waitOnBusy (10);
	delete (myGPIO);
	// delete our endFunc array
	delete (endFuncArrayData);
	return 0;
}
</pre>
 Run the output of the GPIO pin through an oscilloscope to see the duty cycle change from 0 to 1 and back to 0 10 times a second. Run the output through a low pass filter first to see a fairly clean cosine wave with a frequency of 10 Hz</p>

<h2>About the Pthread</h2>
<p>For those wanting a better understanding of how pulsedThread works behind the scenes, a description of the functions and data used by the Pthread are presented here. The pulsedThread constructors create a new Pthread and start it running pulsedThreadFunc with a pointer to a taskParams Structure, theTask:<br>
pthread_create(&theTask.taskThread, NULL, &pulsedThreadFunc, (void *)&theTask);<br>
The constructors also initialize a mutex and a condition variable used for signaling between the pulsedThread object and the Pthread running pulsedThreadFunc, and save pointers to these in thetask:<br>
pthread_mutex_init(&theTask.taskMutex, NULL);<br>
pthread_cond_init (&theTask.taskVar, NULL);<br>
</p>

<h2><a name= "pulsedThreadFunc">pulsedThreadFunc function run by Pthread</a></h2>
<p>In order to be run by a Pthread, our pulsedThreadFunc must be a C-style function, not a C++ class method:<br>
extern "C" void* pulsedThreadFunc (void * tData){<br>
tData is a void pointer to the taskParams Structure we referred to in pthread_create. The first thing pulsedThreadFunc does is cast tData to a task param stuct pointer<br>
taskParams *theTask = (taskParams *) tData;</p>

<p>The basic strategy of a resident thread, as opposed to a thread that does a task and then exits, is to do any needed initialization, and then enter an infinite loop, waiting for tasks to be requested, and doing the tasks. This is the strategy used by pulsedThreadFunc. In the initialization, pulsedThreadFunc makes some structures used for pulse delay and duration timing, and requests the maximum priority from the operating system thread scheduler.</p>

<p>pulsedThreadFunc then enters an infinite loop, an enpty for loop in this case:
<pre>
// loop forever, doing task and modding task
for (;;){
	// get the lock on doTask and wait for a task to be called, or a timing or customMod param to be modded
	pthread_mutex_lock (&theTask->taskMutex);
	while (theTask->doTask==0)
		pthread_cond_wait(&theTask->taskVar, &theTask->taskMutex);
</pre>
Using the Pthreads library function pthread_cond_wait, the execution of pulsedThreadFunc is stalled until theTask->doTask is modified from outside the Pthread by the pulsedThread object. Setting doTask to the number of pulses or trains requested is how a pulsedThread object requests the Pthread to start a pulse or a train. Note that the higher order bits of doTask are used to signal pulsedThreadFunc to change timing paramaters or custom data. You can have many pulsedThread objects extant at once, but they only use processor time when they are actively doing a task.</p>

<p>Once woken by a change to doTask, pulsedThreadFunc first looks for modifications of the taskVar that would require it to reconfigure timers for pulse delay and duration, or to run a function to modify custom data.</p>

<a name= "taskParams_Struct"><h3>taskParams Structure</h3></a>
the taskParams structure is readable and writable by methods of the pulsedThread object and from the Pthread running pulsedThreadFunc. The fields of the taskParams structure are:

<h4>int accLevel</h4><p>This value sets the method that the pthread uses to control pulse timing. Threads can: 0) sleep for pulse duration/delay, 1) sleep for most of the delay duration, waking up and looping for the last few hundred microseconds (controlled by constant kSLEEPTURNAROUND), or 2) re-calculate sleep time for each duration/delay, and completely countermand sleeping if pthread is running late.</p>

<h4>unsigned int doTask</h4>
The lower 29 bits of this 32 bit unsigned integer are used for setting/tracking number of tasks requested/left to do. Changes to this variable are made after calling pthread_mutex_lock, and the pthread is signalled that a change has been made with pthread_cond_signal. The pthread sleeps when doTask is zero, and wakes when doTask is non zero. For a finite length train or a pulse task, the pthread starts doing its task, decrementing doTask as it completes each task (single pulse or train), and sleeps again when doTask gets to 0. For an infinite train, the pthread starts when doTask =1 and stops the train when doTask = 0, but as it only reads and never writes to doTask, locking the mutex is not required.

<p>The upper 3 bits of doTask are reserved for alerting the pthread that pulse delay, pulse duration, or custom thread data have been changed:
<table cellspacing="0" cellpadding="0" border = "1">
	<caption>doTask Signal Bits</caption>
<tbody>
	<tr>
		<td>Constant</td>
		<td>Value</td>
		<td>Bit</td>
		<td>Meaning</td>
	</tr>
	<tr>
		<td>const unsigned int kMODDELAY</td>
		<td>536870912</td>
		<td>2<sup>29</sup></td>
		<td>set when pulse delay is changed</td>
	</tr>
	<tr>
		<td>const unsigned int kMODDUR</td> 
		<td>1073741824</td>
		<td>2<sup>30</sup></td>
		<td>set when pulse duration is changed</td>
	<tr>
		<td>const unsigned int kMODCUSTOM</td>
		<td>2147483648</td>
		<td>2<sup>31</sup></td>
		<td>set when task custom data is changed</td>
	</tr>
</tbody>
</table>
Setting any of these these bits from the pulsedThread object causes the pthread to be awakened and it will change timers for delay/duration or call the custom task modification function. The pthread will then unset the signal bits.</p>

<h4>Pulse Description</h4>
The timing of pulses is stored in two complementary ways, one based on delay and duration times, and the other on frequency and duty cycle.  
<table cellspacing="0" cellpadding="0" border = "1">
	<caption>Pulse Description (time based)</caption>
	<tbody>
	<tr>
		<td><B>unsigned int pulseDelayUsecs</B></td>
		<td>The duration of "low" time in microseconds, >=0. For a train or infinite train,(but not for a single pulse), setting pulseDelayUsecs = 0 means the loFunc is never called.</td>
	</tr>
	<tr>
		<td><B>unsigned int pulseDurUsecs</B></td>
		<td>The duration of "high" time in microseconds, must be > 0. If your task is periodic, but not a pulse with defined "high" and "low", set pulseDelayUsecs to 0 and control timing with pulseDurUsecs only</td>
</tr>
<tr>
<td><B>unsigned int nPulses</B></td>
<td>The number of pulses in a train. Can be 0 for an infinite train, 1 for a single pulse, >=2 for a train of defined length.</td>
</tr>
</tbody>
</table>
<br>
<table cellspacing="0" cellpadding="0" border = "1">
	<caption>Train Description (Frequency Based)</caption>
	<tbody>
		<tr>
			<td><B>float trainDuration</B></td>
			<td>The duration of the train, in seconds, or 0 for an infinite train</td>
		</tr>
		<tr>
			<td><B>float trainFrequency</B></td>
			<td>The frequency in Hz, i.e., pulses/second</td>
		</tr>
		<tr>
			<td><B>float trainDutyCycle</B></td>
			<td>Duty Cycle = PulseDurUsecs/(pulseDurUsecs + pulseDelayUsecs), 0 &lt; Duty Cycle &lt;1</td>
		</tr>
	</tbody>
</table>
This duplication is for the benefit of functions that, for example, change train frequency without changing train duration by modifying the number of pulses. Frequency-based description is not well suited for describing single pulses. Pulse timing by the pthread always uses the time based microseconds, with nanosleep function.

<h4>void (*hiFunc)(void *) and void (*loFunc)(void *)</h4>
hiFunc and loFunc are pointers to the custom functions that run at the start of the duration (High Function) and delay (Low Function) periods of a pulse. The user needs to provide these functions when creating a new pulsedThread object. They each get a void pointer to custom taskData, which they can recast to the correct type to operate on.  The execution time of hiFunc and loFunc need to be short relative to pulse delay/duration.

<h4>void * taskData</h4>
taskData is a pointer to data customized for the thread's main task, running hiFunc and loFunc.  Any needed data other than pulse timing and number are accessed with this pointer.  It needs to be initialized when the pthread is started, with anything from a single value to a large structure, depending on what the task of the pthread needs. The hiFunc and loFunc are both passed this pointer.  Remember that the pulsedThread object can access this data as well, so it can be used to return data as well as to signal a thread. If the pulsedThread object writes to the parts of taskData used by the pulsedThreadFunc function, you may wish to use the mutex for protection.

<h4>void * endFuncData</h4>
Pointer to optional function that can be set to run at the end of every task. Thus, it would run at the end of a train (nPulses &gt2;= 2), or at the end of each pulse for an infinite train or single pulse. The task structure includes a pointer specifically for data used by an endFunction, but the endFunction gets the pointer to the whole task structure, so it may be used, e.g, to change task timing.

<h4>void (*endFunc)(void *, taskParams *)</h4>
An end Function is a function pointer to an optional user-provided function that runs at the end of each train for tasks configured as finite length trains, or at the end of each pulse for tasks configured as a single pulse or an infinite train.  An endFunc gets a void pointer to the endFunc data, plus a pointer to the whole taskParams structure, to make it easy for an endFunc to modify pulse timing or number.  If the user does not provide an endFunc, the pointer for endFunc will be NULL, and no endFunc will be run by pulsedThreadFunc.

<h4>void * endFuncData</h4>
endFuncData is a pointer specially reserved for data customized for an End Function, if one is installed. This pointer is separate from the taskData pointer so that handling of End Functions and associated data can be independent of hiFunc and loFunc task data.  That is, you can have an endFunc that is task agnostic, and you can install and un-install End Functions without affecting the main task.

<h4>int (*modCustomFunc)(void *, taskParams *)</h4>
modCustomFunc is a pointer to a user-provided function that is run by pulsedThreadFunc when kMODCUSTOM is set in doTask. This provides a thread-safe way to modify the task data or endFunc data, as pulsedThreadFunc will wait until a pulse ot train is completed before running the modCustomFunc. The modCustomFunc gets a pointer to modCustomData and a pointer to taskParams.

<h4>void * modCustomData</h4>
modCustomData is pointer to the data to be used by a modCustomFunc to modify the task data or endFunc data. It needs to be initialized before modCustomFunc is called.

<h4>pthread_t taskThread, pthread_mutex_t taskMutex, and pthread_cond_t taskVar</h4>
These are data structures provided by pthread.h. taskThread is a pthread structure, initialized when the pthread is created, and freed in the pulsedThread destructor. taskMutex is a mutex that is used in the lock and unlock operations to prevent simultaneous writing by the pthread and the pulsedThread object to doTask or perhaps taskData or endFuncData.  taskVar is a conditon variable used to signal from a pulsedThread object to the associate pthread that doTask has been modified and there is work to do.  The pthread uses the pthread_cond_wait function to sleep until a task has been called, then does the task(s)and sleeps again.




<a name= "Python_C_Module"><h2>Using pulsedThread in a Python/C Module</h2></a>
<p>To use the pulsedThread C++ library in a Python module, you can start with the wrapper functions provided in the file pyPulsedThread.h.  These functions are designed to work with a pulsedThread object on the C++ side of things and a PyCapsule object containing a pointer to that pulsedThread object on the Python side of things. For general information on writing Python/C modules, see the <a href="https://docs.python.org/3.4/c-api/index.html">Python/C API Reference Manual</a></p>

<p>As when using pulsedThread directly from C++, you must supply at minimum the C++ functions for initialization of the taskCustom data, and HI and LO event functions. Your initialization function must return a PyCapsule containing a pointer to a pulsedThread object.  The functions in pyPulsedThread.h can then interact with the PyCapsule object asking it to do tasks and configure pulse/train timing.  You must also supply a Python/C module function that makes a new pulsedThread using your initialization and HI and LO functions. Other modules that wish to include pyPulsedThread.h need to provide an initialization function that returns a PyCapsule containing a pointer to a pulsedThread object. The functions in pyPulsedThread can then interact with the PyCapsule object asking it to do tasks and configure pulse/train timing. This function must return to Python a PyCapsule that wraps a pointer to your pulsedThread object. From Python, you pass that PyCapsule as a parameter to functions from pyPulsedThread.h that interact with the pulsedThread object, asking it to do tasks and configure pulse/train timing.</p>


<p>Wrappers for almost all of the pulsedThread library control functions and setters and getters are provided. They are called from Python as follows:
<dl>
<dt>isBusy (PyCapsule pulsedThreadPtr)</dt>
<dd>Returns number of tasks a pthread has left to do, 0 means finished all tasks</dd>
<dt>waitOnBusy (PyCapsule pulsedThreadPtr, float timeOut) </dt>
<dd>Returns when a pthread is no longer busy, or after timeOut secs</dd>
<dt>doTask (PyCapsule pulsedThreadPtr)</dt>
<dd>Tells the pulsedThread object to do whatever pulse or train it was configured for</dd>
<dt>doTasks (PyCapsule pulsedThreadPtr, int numTasks)</dt>
<dd>Tells the pulsedThread object to do whatever pulse or train it was configured for numTasks times without stopping in between.</dd>
<dt>startTrain (PyCapsule pulsedThreadPtr)</dt>
<dd>Tells a pulsedThread object configured as an infinite train to start</dd>
<dd>stopTrain (PyCapsule pulsedThreadPtr)</dd>
<dt>Tells a pulsedThread object configured as an infinite train to stop</dt>
<dt>modDelay (PyCapsule pulsedThreadPtr, int delay)</dt>
<dd>sets the delay period of a pulse or LOW period of a train</dd>
<dt>modDur (PyCapsule pulsedThreadPtr, int delay)</dt>
<dd>changes the duration period of a pulse or HIGH period of a train</dd>
<dt>modTrainLength (PyCapsule pulsedThreadPtr, int length)</dt>
<dd>changes the number of pulses of a train</dd>
<dt>modTrainDur (PyCapsule pulsedThreadPtr, float time)</dt>
<dd>changes the total time duration of a train bychanging number of pulses</dd>
<dt>modTrainFreq (PyCapsule pulsedThreadPtr, float freq)</dt>
<dd>changes the frequency of a train preserving duty cycle and time duration</dd>
<dt>modTrainDuty (PyCapsule pulsedThreadPtr, float duty)</dt>
<dd>changes the duty cycle of a train</dd>
<dt>getPulseDelay (PyCapsule pulsedThreadPtr)</dt>
<dd>returns pulse delay, LO time of a train, in seconds</dd>
<dt>getPulseDuration (PyCapsule pulsedThreadPtr)</dt>
<dd>returns pulse duration, HI time of a train, in seconds</dd>
<dt>getPulseNumber (PyCapsule pulsedThreadPtr)</dt>
<dd>returns number of pulses in a train, 1 for a single pulse, or 0 for an infinite train</dd>
<dt>getTrainDuration (PyCapsule pulsedThreadPtr)</dt>
<dd>returns time duration of a train, in seconds</dd>
<dt>getTrainFrequency (PyCapsule pulsedThreadPtr)</dt>
<dd>returns frequency of a train, in Hz</dd>
<dt>getTrainDutyCycle (PyCapsule pulsedThreadPtr)</dt>
<dd>returns duty cycle of a train, ratio of HI time to (HI + LO time),between 0 and 1</dd>
<dt>unsetEndFunc (PyCapsule pulsedThreadPtr)</dt>
<dd>un-sets any end function set for this pulsed thread. Each module must provide its own function for setting an end function.</dd>
<dt>hasEndFunc (PyCapsule pulsedThreadPtr)</dt>
<dd>Returns the endFunc status (1=installed or 0=not installed) for a pulsed thread</dd>
</dl>

<h2>11) Sample Python C++ Module Example</h2>

The file pyGreeter.cpp makes a simple Python C++ module using pyPulsedThread.h. pyGreeter.cpp provides a single function that makes a pulsedThread object and returns a pyCapsule containing a pointer to it.

pulsed_C_Greeter (PyObject *self, PyObject *args);
The parameters passed to this function from Python are a string for a name, and an integer for timing mode. The C module interface passes them to C++ as a pointer to a python object, PyObject *args, and the C module interface function PyArg_ParseTuple is used to parse it into a string and an integer.

const char * localName;
int accLevel;
PyArg_ParseTuple(args,"is",  &amp;accLevel, &amp;localName));
pulsed_C_Greeter makes a new pulsedThread object using the same init, hi, and lo functions, ptTest_Init, ptTest_Hi, and ptTest_Lo, that was used in Greeter.cpp, by #including the Greeter.h header file. pulsed_C_Greeter uses the microsecond delay, microsecond duration, and number of pulses method:

pulsedThread * threadObj = new pulsedThread ((unsigned int)50000, (unsigned int)50000, (unsigned int)10, (void * volatile) &amp;initStruct, &amp;ptTest_Init, &amp;ptTest_Lo, &amp;ptTest_Hi, accLevel, errCode)

Note that printing from the C++ side of things, as done by pt_Test_Hi and ptTest_Lo, means that printed messages appear in the terminal window. This is seamless if launching Python from the terminal. If using an environment like IDlE, launch it from a terminal window, not from the menu, with: idle3 &amp; Then the messages from the C++ module will appear in the terminal window from which IDlE was launched.

Finally, pulsed_C_Greeter returns to Python a PyCapsule wrapping the pulsedThread object:

return PyCapsule_New (static_cast &lt;void *&gt;(threadObj), "pulsedThread", pulsedThread_del);
You can build the module ptGreeter with the provided Python setup script.

python3 setup_ptGreeter.py build_ext --inplace

Use "build_ext --inplace" instead of "install" to install it in the local folder so you can easily delete it after building it and running it, as it is not useful enough to be a permanently installed library.

The Python code in PTGreeter.py demonstrates making a wrapper providing a "Pythonic" interface, the class PT_Greeter, for an external module based on the C++ pulsedThread library, in this case ptGreeter. A PTGreeter object contains a field, task_ptr, for a PyCapsule object containing a pointer to a pulsedThread object on the C++ side. The main function works similarly to that of the C++ program described in Greeter.cpp. It makes two pulsedThreads that print greetings, and sets them running at the same time. Then it starts doing calculations and printing results in a loop.





12) ptPyFuncs: pulsedThreads with Python Functions

ptPyFuncs is a Python C++ module that allows you to use the pulsedThread C++ library from Python for threading and timing of Python tasks without writing and compiling a dedicated Python C++ module. ptPyFuncs provides functions to initialize a pulsedThread with a Python object that has HiFunc, LoFunc, and (possibly) endFunc methods.

ptPyFuncs.initByPulse (Python object, int lowTicks, int highTicks,int nPulses, int ACClevel)
ptPyFuncs.initByFreq (Python object, frequency, duty Cycle, float train duration, accuracy_level)
In both cases, the first argument is a Python object that MUST have methods named exactly "HiFunc" and "LoFunc" that don't take extra parameters other than self. The other parameters for initialization are for pthread timing which is done as usual in C++ as described earlier. Now, however, the high, low and end functions are callbacks to the Python object's HiFunc, LoFunc, and EndFunc, and thus run in Python with full access to the Python environment. Yes, with some care, a Python C module can call Python functions, even from separate C threads. The Python interpreter runs only one thread at a time and uses a Global Interpreter Lock (GIL) to arbitrate which thread is currently running. The code in ptPyFuncs uses Python/C API functions PyGILState_Ensure to get the lock before calling any Python functions and PyGILState_Release to release the lock when finished. It is possible to end up in a deadlock if, for instance, a C module function gets the GIL and then calls a Python function that calls another C module function that also tries to get the GIL.

As described before, both init functions return a PyCapsule object wrapping the C++ pulsedThread object, allowing it to be controlled with the entire set of functions from pyPulsedThread.h. Setting timing and requesting tasks functions as before.

You can change the Python object whose functions the pulsedThread C++ object calls with:

ptPyFuncs.setTaskObject(PyCapsule, Python Object)
The first argument is the Python pyCapsule that points to the pulsedThread, and the second argument is a Python object providing the HI and LO functions, as described previously.

You can set an endFunction from a Python object, which can be the same object as used for the task, with:

ptPyFuncs.setEndFunctionObject(PyCapsule, Python Object, functionParamType)
The Python Object must have a method named exactly "EndFunc" that gets passed 4 parameters describing pulse number and timing. If functionParamType is 0, the endFunc is called with with microseond pulse delay, duration, and number of pulses as the first three parameters. If functionParamType is non-zero, the endFunc is called with train frequency, duty cycle, and train length. In either case, the 4th parameter is the number of tasks left to be done.

You can install the ptPyFuncs module from a terminal with:

sudo python3 setup_pyPTpyFuncs.py install
PT_Py_Greeter is a Python class that uses ptPyFuncs to, what else, print hellos and goodbyes. Only now, printing is done within the Python environment by Python objects.

The PT_Py_Greeter class field task_ptr is a pyCapsule that points to a pulsedThread object on the C++ side of things. All the calls to the C++ code is through an object's task_ptr, which is created in the PT_Py_Greeter init method.

The main function makes a PT_Py_Greeter and sets it going, then does some calculations in a loop, printing results as it goes, to show the independence of the threaded PT_Py_Greeter from the main code.The class field PSEUDO_MUTEX is used for preventing print statements from different places in the code from executing at the same time, which would lead to garbled output. Unlike a real mutex, execution is not halted while waiting on the PSEUDO_MUTEX, hence the loops with calls to sleep to allow the other threads of execution to continue while waitng for the PSEUDO_MUTEX to be free. Also, read/write to the PSEUDO_MUTEX is not atomic; one thread may read PSEUDO_MUTEX as 0, and set it to 1, but in the very brief interval between reading and writing to PSEUDO_MUTEX, another thread may have read PSEUDO_MUTEX as 0 and so both threads would think they have the mutex.




</body>
</html>
