<!DOCTYPE html>
<HTML>
<head>
<title>pulsedThread</title>
<META NAME="AUTHOR" CONTENT="Jamie Boyd">
</head>
<H1>Documentation for pulsedThread</H1>
<p>PulsedThread uses the <a href = "http://pubs.opengroup.org/onlinepubs/7908799/xsh/pthread.h.html">POSIX pthread library</a> to set up and control a threaded task for precise, independent timing of events that can be categorized as pulses or trains of pulses. PulsedThread uses a mix of C++ class methods and C-style functions and structures to use the pthread C library with the convenience of C++ classes. The pulsedThread class methods wrap up all the pthread calls so that use of the pulsedThread class  from your own C++ code requires no knowledge of the pthread library, and only limited knowledge of the C-style structures and functions used by pulsedThread.</p>

</p>Under the hood, a pulsedThread object uses pthread library functions to start and control a separate thread, running <b>pulsedThreadFunc</b>. The pthread running pulsedThreadFunc controls all of the pulse timing, and calls user-supplied functions with user-supplied data at the starts of the high and low periods of each pulse.  Each pulsedThread object has a <B>taskParams</B> structure that both it and its associated pthread can access, containing pointers to the user-supplied functions and data and pulse timing information. The pulsedThread object communicates with its associated pthread through this taskParams structure: configuring pulse timing and number; telling the pthread to do pulses or trains; perhaps getting results back from the pthread.</p> 

<p>The PulsedThread project also contains code for making <a href = "https://docs.python.org/3.5/extending/building.html">Python C-modules</a> that can make and control pulsedThread objects from Python.  Some simple examples making Python C-modules using pulsedThread are included.</p>

<p>PulsedThread was originally written to control Raspberry Pi GPIO hardware. The <a href= "https://github.com/jamieboyd/GPIO_Thread">GPIO_Thread</a> project uses the pulsedThread project to make C++ classes and Python C-modules that output independently timed pulses or trains of pulses on standard GPIO pins, including running a 2-phase stepper motor, and to output wave forms or control a servo-motor using the PWM peripheral.</p>
<h2>Table of Contents</h2>
<ol>
	<li><a href = "#LIST_OF_FILES">List of Files</a></li>
	<li><a href="#Pulsed_Thread_Events">Pulsed Thread Events And Timing</a></li>
	<li><a href = "#Task_Functions_and_Data">User-supplied Task Functions and Data</a></li>
	<li>The pulsedThread Class</a>
	<ol>
		<li><a href = "#Constructors">Constructors</a></li>
		<li><a href = "#Running_A_Thread">Running Pulsed Thread Tasks</a></li>
		<li><a href= "#Changing_Pulse_Timing">Changing Pulse Number and Timing</a></li>
	</ol>
	</li>
</ol>

<a name="LIST_OF_FILES"><h2>List of Files</h2></a>
<dl>
	<dt>pulsedThread (pulsedThread.cpp, pulsedThread.h)</dt>
	<dd>- Contains the pulsedThread C++ class that starts and controls a pthread, the C-style function run by the pthread, and the data structure that the pulsedThread object and associated pthread share.  pulsedThread.h also contains some utility functions for setting and configuring timers using system time functions and some constants whose uses are described below.</dd>
	<dt>Greeter (Greeter.h, Greeter.cpp) and MinimalGreeter (minimalGreeter.cpp)</dt>
	<dd>- Make simple C++ test programs that use the pulsedThread class.  They simply print messages to the command line</dd>
	<dt>pyPulsedThread.h </dt>
	<dd>- Contains a collection of functions for controlling a pulsedThread object wrapped in a PyCapsule, with wrappers for many pulsedThread functions.  It is useful for building Python C-modules controlling pulsedThread objects.</dd>
	<dt>makefile</dt>
	<dd>- Make file that compiles and installs pulsedThread as a C++ library, copies pulsedThread.h and pyPulsedThread.h to system library directories, and optionaly compiles Greeter or MinimalGreeter. Run in order (the last two are optional): <ol><li>make</li><li>sudo make install</li><li>make greeter</li><li>make minimalGreeter</li></ol></dd>
	<dt>pyGreeter.cpp</dt>
	<dd>- Describes a simple Python C-module, ptGreeter, that uses the pulsedThread library and the code from Greeter.cpp with functions from pyPulsedThread.h to make a Python C-module that prints messages from a pulsedThread object.</dd>
	<dt>setup_ptGreeter.py</dt>
	<dd>- Setup code to compile the ptGreeter C module. Run: python3 setup_ptGreeter.py build_ext --inplace. </dd>
	<dt>PTGreeter.py</dt>
	<dd>- Makes a Python wrapper providing a "Pythonic" object interface to ptGreeter. Run from command line, not IDLE, as python3 PTGreeter.py to see independent output from  Python and C++ object.</dd>
	<dt>pyPTpyFuncs.cpp</dt>
	<dd>- Uses code from PyPulsedThread.h to make a Python C-module, ptPyFuncs, that runs callbacks for the high and low functions from a user-provided Python object.</dd>
	<dt>setup_pyPTpyFuncs.py</dt>
	<dd>- Setup code to compile the ptPyFuncs C module. Run: python3 setup_setup_pyPTpyFuncs.py install</dd>
	<dt>PTpyGreeter.py</dt>
	<dd>- Uses ptPyFuncs in a Python class whose HiFunc and LoFunc simply print hellos and good byes. All printing is done from Python, so it can be run form IDLE.</dd>
	<dt>PTpyGPIOTrain.py</dt>
	<dd>- For Raspberry Pi only, uses ptPyFuncs in a Python class whose HiFunc and LoFunc use RPi.GPIO to make a train of pulses on a GPIO pin with pulse width modulation.</dd>
</dl>

<a NAME="Pulsed_Thread_Events"><h2>PulsedThread Events and Timing</h2></a>
Each pulsedThread object starts a pthread that runs a function, pulsedThreadFunc, that controls periodic timing of events in a pulsed fashion; a "set high" event happens at the start of each pulse and a "set low" event happens after the pulse duration, with a delay between pulses. You define pulse duration and delay, the number of pulses, and the set high and set low events. The high and low events are defined by function calls; each pulsedThread object is initialized with a pair of function pointers for the functions that are called on the "High" and "Low" events (referred to as HiFunc and LoFunc). These function pointers, as well as pointers to all needed data, is stored in a taskParams structure accessed by both the pulsedThread object and the pthread running pulsedThreadFunc.</p>

<p>Three types of events are supported: single pulses, trains of a defined number of pulses, and infinite trains of an unlimited number of pulses. These three types are coded as integers, and have defined constants for ease of use.
<table cellspacing="0" cellpadding="0" border = "1">
	<caption>Three Types of pulsedThread Events</caption>
<tbody>
	<tr>
		<td>Constant</td>
		<td>Value</td>
		<td>Meaning</td>
	</tr>
	<tr>
		<td>const int kPULSE</td>
		<td>1</td>
		<td>Waits for delay, calls HiFunc, waits for duration, calls LoFunc</td>
	</tr>
	<tr>
		<td>const int kTRAIN</td>
		<td>2</td>
		<td>Calls hiFunc, waits for duration, if Delay > 0, calls loFunc and waits for delay, repeats for set number of Pulses</td>
	</tr>
	<td>const int kINFINITETRAIN</td>
	<td>0</td>
	<td>Calls hiFunc, waits for duration, calls loFunc and waits for delay, repeats until requested to stop</td>
</tr>
</tbody>
</table>
A single pulse waits for the delay, runs the HiFunc, then waits for the duration, and runs the LowFunc. You need to initialize a pulse in the low state.  Remember that "high"and "low" are notional, not actual descriptions, so programming a high-to-low pulse is as simple as swapping the hiFunc with the loFunc.  A train repeatedly runs the HiFunc and waits for the duration, then runs the LowFunc and waits for the delay, repeating for a defined number of pulses. An infinite train has no set number of pulses, but can be stopped and restarted arbitrarily. </p>

<p>Pulse timing is controlled with the system microsecond timer and the nanosleep function. Three methods of timing are provided, of increasing accuracy and processor use. The first method is for the pthread to sleep for the entire time of a pulse duration. This method requires the least amount of processor time, but it ignores both the time it takes for the Hi and Lo functions to run, and the non-zero, and variable, time that it takes for a sleeping pthread to wake.  There is a lower limit on how long a pthread can sleep; calling for shorter sleeps will give sleeps no shorter than this limit. In fact, sleep is guaranteed to sleep a pthread for <b>at least</b> as long as requested, but may sleep it for longer than requested, sometimes much longer, depending on thread scheduling by the operating system.  Nonetheless, this may be accurate enough for many purposes, at relatively lower frequencies, and with short, constant duration tasks.  A more accurate but more processor intensive method is for the pthread to calculate and record the end time of each duration, sleep for the requested duration minus some small constant time, and upon awakening, repeatedly check the time in a tight loop until the duration has ended. For durations smaller than this constant time, the pthread is not slept at all, but goes directly to spinning.  For Hi and Lo events that may take long relative to pulse timing, or be of variable duration, a third timing method is available that calculates the sleep period needed for each duration to keep the pthread on schedule, and can countermand sleeping if a pthread is running behind. This method can not completely eliminate jitter, but will keep the average frequency remakably constant.  These three methods are coded as integers, and have constants defined that can be used, for instance, in the pulsedThread constructors:
<table cellspacing="0" cellpadding="0" border = "1">
	<caption>Three Modes of pulsedThread Timing</caption>
<tbody>
	<tr>
		<td>Constant</td>
		<td>Value</td>
		<td>Meaning</td>
	</tr>
	<tr>
		<td>const int ACC_MODE_SLEEPS</td>
		<td>0</td>
		<td>Thread sleeps for defined duration of period</td>
	</tr>
	<tr>
		<td>const int ACC_MODE_SLEEPS_AND_SPINS</td>
		<td>1</td>
		<td>Thread sleeps for period - kSLEEPTURNAROUND microseconds,then spins for remaining time</td>
	</tr>
	<tr>
		<td>const int ACC_MODE_SLEEPS_AND_OR_SPINS</td>
		<td>2</td>
		<td>Sleep time is re-calculated for each duration, sleep is countermanded if pthread is running late</td>
	</tr>
	</tbody>
</table>

A constant, kSLEEPTURNAROUND,  defines how long, in microseconds, we aim to spin at the end of pulse timing in the second and third accuracy levels. The default value is 200 microseconds. Making this time longer may improve accuracy; making it shorter will decrease processor usage. If you change the constant, you will need to recompile the pulsedThread library. </p>

<a NAME = "Task_Functions_and_Data"><h2>User-supplied Task Functions and Data</h2></a>
<p>The job of a pulsedThread is the timing of the setHigh and setLow events of some pulsed task, but what that task is, and what those events do, is is up to you. This flexibility is provided by function references to functions that take a single void pointer; your own functions are called with your own data.
<dl>
	<dt>void (*gHiFunc)(void * volatile)</dt>
	<dd>user-provided function that is called at the start of the high period of each pulse. The void pointer points to user's custom data.</dd>
	<dt>void (*gLoFunc)(void * volatile)</dt>
	<dd>user-provided function that is called at the start of the low period of each pulse. The void pointer points to user's custom data.</dd>
</dl>
You need to write at least one function with the above signature, and pass the address of that function to the pulsedThread. </p>

<p>When the pulsedThreadFunc calls your hiFunc or loFunc, the void pointer will point to your custom data. You must have previously created this data and passed a pointer to it to the pulsedThread. Your hiFunc and loFunc must first cast the void pointer to a pointer of the correct type before accessing your data. Your data can be anything from a single integer to a custom-defined structure that holds many fields of different types. Your hiFunc and loFunc can read and write to your custom data. The pulsedThread object can also read and write to your custom data. The pulsedThread class methods and the pulsedThreadFunc run by its associated  pthread use a mutual exclusion variable (pthread_mutex_t type) to prevent modifying the data at the same time. Some of the pulsedThread class methods have an optional variable to lock this mutex before modifying the pthread data, which cna be set if the method is called when the pthread is running its task. The principle of passing both functions and data to the pthread is also used for modifying pthread data after a pthread is created. The functions passed to the pthread for the pthread to call are referred to as call-backs.</p>

<h2>The PulsedThread Class</h2>
<a NAME="Constructors"><h3>Constructors</h3></a>
<p>There are two constructors for the pulsedThread class, one sets initial pthread timing based on integer numbers of microseconds for delay, duration, and number of pulses. The other sets pulse timing based on floating point values for frequency (Hz), duty cycle (0 to 1), and train duration (seconds).  Each integer specified timing has a unique floating point representation, and vice versa, within the extent of rounding errors. Saving timing information in both formats in the taskParams structure is redundant, but allows easy conversions between the two modes of description. The ticks2times and times2ticks utility functions are used to convert between the two formats. The remaining six parameters are the same for both constructors, concering the hiFunc and loFunc, and the data for them to use.</p>

<p>The pulsedThread user needs to supply the loFunc and hiFunc run by the thread, and task data for the hiFunc and loFunc to operate on. The <b>taskParams</b> structure contains a field for a pointer to taskData, for data specific to that particular pulsedThread object. This way, different pulsedThread objects can be running the same set of hiFunc and loFunc, but using different data (e.g., GPIO pin numbers). The taskData is initialized by the pulsedThread constructor with data from the initData parameter, a void pointer to the initialization data created by the user.  If no user-supplied call-back is provided (initFunc is a nullptr), then the taskData pointer in the taskParams struct is simply set to the initData pointer.  In this case, the initData becomes the taskData, and the user must make sure the initData pointer remains valid for the life of the pulsedThread object. If an initFunc <b>is</b> provided, then it is called with a void pointer to initData, and a by-reference void pointer to the taskData pointer in the taskParams struct: <br>int (*)(void *, void * &amp;)<br>and is called in the constructor like this:<br>errCode =initFunc(initData , theTask.taskData);<br>The initFunc can allocate the taskData pointer to whatever memory it needs, and copy over data from the initData. In this way, the user does not need to keep track of the initData, making sure that it is or modified or deleted when the pthread still needs it.</p>
<ul>
<li>pulsedThread::pulsedThread (unsigned int gDelay, unsigned int gDur, unsigned int gPulses, void *initData, int (*initFunc)(void *, void * volatile &amp;), void (*gLoFunc)(void * volatile), void (*gHiFunc)(void * volatile),int gAccLevel,int &amp;errCode)
<br>(first 3 params using Integer values - make sure to cast all 3 parameters to unsigned int)</li>
<li><ol><li>unsigned int gDelay - for a single pulse, delay until HiFunc runs, in microseconds. For trains, duration between LoFunc and HiFunc</li>
<li>unsigned int gDur - for a single pulse, duration between HiFunc and LoFunc that ends the pulse. For trains, duration between HiFunc and LoFunc</li>
<li>unsigned int gPulses - 1 to make a pulse, 2 or greater to indicate the number of pulses in a train, or 0 to make an infinite train</li></ol><br></li>
<li>pulsedThread::pulsedThread (float gFrequency, float gDutyCycle, float gTrainDuration , void *initData, int (*initFunc)(void *, void * volatile &amp;), void (*gLoFunc)(void * volatile), void (*gHiFunc)(void * volatile),int gAccLevel,int &amp;errCode)<br>(first 3 params using floating point values - make sure to cast all 3 parameters to float)</li>
<li><ol><li>float gFrequency - pulse frequency in Hz</li>
<li>float gDutyCycle - pulse duty cycle, from 0 &lt; duty cycle &lt;= 1</li>
<li>float gTrainDuration - duration of the train, in seconds. set to 0 for infinite train, set to length of one pulse for a single pulse</li></ol><br>
(Rest of the parameters, same for both constructors)</li>
<li><ol start = "4"><li>void *initData - pointer to whatever data you want to use when initializing the pulsedThread object.</li>
<li>int (*initFunc)(void *, void * volatile &amp;) - function pointer for initialization function, or nullptr if no special initialization function is provided</li>
<li>void (*gLoFunc)(void * volatile) - Your LoFunc is run on high to low transitions. It gets passed a pointer to the taskCustomData you initialized</li>
<li>void (*gHiFunc)(void * volatile) - Your HiFunc is run on low to high transitions. It gets passed a pointer tothe taskCustomData you initialized</li>
<li>int gAccLevel - sets the method that the pthread uses to control pulse timing.</li>
<li>int &amp;errCode - reference variable that is set to 0 if no error during pulsedThread creation, else set to non-zero</li></ol>
</ul>

<a NAME="Running_A_Thread"><h3>Running PulsedThread Tasks</h3></a>
Once you have made a pulsedThread object, you tell it to do the pulse or train for which it is configured with a call to class methods DoTask or DoTasks:
<dl>
	<dt>void DoTask (void)</dt>
	<dd>signals the pthread to run the configured task (pulse or train) once</dd>
	<dt>DoTasks(unsigned int nTasks)</dt>
	<dd>signals the pthread to run the configured task nTasks times in a row</dd>
</dl>
<p>Note that the pthread will be busy for the duration of the task or tasks, but DoTask or DoTasks will return immediately, and the pulsedThread object will be ready to accept other commands. Thus, you can add more task requests while the originals are still being processed.</p>
<p>DoTask increments the doTask field in the taskParams structure shared by the pulsedThread and its pthread. DoTasks will add nTasks to the doTask field. Making doTask non-zero will wake up the pthread and it will perform its task, or tasks. The doTask field in the taskParams structure is an unsigned 32 bit integer, but the 8 upper bits are reserved for signalling events that the pthread has to respond to. This means you can request a maximum of 2<sup>29</sup>-1=536,870,911 tasks.</p>

<p>Two special functions, startInfiniteTrain and stopInfinteTrain, are used for starting and stopping infinite trains.
<dl>
	<dt>void startInfiniteTrain (void)</dt>
	<dd>starts a pulsedThread configured as an infinite train</dd>
	<dt>void stopInfinteTrain(void)</dt>
	<dd>stops an infinite train. it can be restarted with startInfiniteTrain without having to reconfigure it.</dd>
</dl></p>

<p>You can ask if the pthread of a pulsedThread is still busy doing a task, or you can wait until a pulsedThreads pthread is done a task:
<dl>
	<dt>int isBusy(void )<dt>
	<dd>returns 0 if its pthread is not currently doing a task, else returns the number of tasks still left to do. An infinite train returns 1 if it is active, 0 if it is not active.</dd>
	<dt>int waitOnBusy(float waitSecs)</dt>
	<dd>does not return until its pthread is no longer busy, or until waitSecs seconds has elapsed, whichever happens first.  The return vlaue is 0 if the pthread finished the tasks before waitSecs, or returns the number of tasks still left to do if the pthread did not finish before the waitSecs timeout expired. Calling waitonBusy for an infinite train is allowed, and will return 1 after waitSecs.<dd>
</dl></p>

<a name = "Changing_Pulse_Timing"><h3>Changing Pulse Number and Timing</h3></a>
<p>There are a number of functions to change the timing of a pulsedThread task after it has already been created. As for creating the pulsedThread, the task modification function use either integer pulse number and delay/duration microseconds or frequencies, dutycycles, and train durations in floating point values. The integer functions are:
<dl>
	<dt>int modDelay (unsigned int newDelay)</dt>
	<dd>modifies low time of each pulse</dd>
	<dt>int modDur (unsigned int newDurUsecs)</dt>
	<dd>modifies high time of each pulse</dd>
	<dt>int modTrainLength (unsigned int newPulses)</dt>
	<dd>modifies number of pulses in a train. A train must always have at least 2 pulses.</dd>
</dl>
The frequency/dutycycle/train duration modification functions are:
<dl>
	<dt>int modFreq (float newFreq)</dt>
	<dd>changes the frequency of the pulses, in Hz, while keeping duty cycle and train duration (in seconds) constant</dd>
	<dt>int modTrainDur (float newDur)</dt>
	<dd>Changes train duration (in seconds) by changing train length (number of pulses), keeping frequency and dutycycle constant</dd>
	<dt>int modDutyCycle (float newDutyCycle)</dt>
	<dd>Changes the duty cycle of the train, keeping the frequency and the train length constant.</dd>
</dl>
As can be seen, changing one of the integer parameters will change several of the floating point parameters, and changing one of the floating point parameters will change several of the integer parameters. After each modification of timing parameters, one of the ticks2Times or times2Ticks utility functions is called as appropriate to update the other set of parameters. The pulsedThread class has functions for getting the timing parameters, in both formats:
<dl>
	<dt>unsigned int getNpulses (void)</dt>
	<dd>returns 0 for an infinite train, the number of pulses in a finite train, or 1 for a single pulse</dd>
	<dt>int getpulseDurUsecs (void)</dt>
	<dd>returns pulse duration (HI time) in microseconds</dd>
	<dt>int getpulseDelayUsecs (void) - returns pulse delay (LO time) in microseconds
	<dt>getTrainDuration (void)</dt>
	<dd>returns train duration in seconds</dd>
	<dt>getTrainFrequency (void)</dt>
	<dd>returns train frequency in Hz</dd>
	<dt>getTrainDutyCycle (void)</dt>
	<dd>returns train duty cycle (0 -1)</dd>
</dl></p>

<p>You can also change the hiFunc and loFunc functions by changing the function pointers stored in the taskParams structure:
<dl>
	<dt>setLowFunc (void (*loFunc)(void * volatile))</dt>
	<dd>sets function to run for Lo events</dd>
	<dt>setHighFunc (void (*hiFunc)(void * volatile))</dt>
	<dd>sets function to run for Hi events</dd>
</dl>
The hiFunc and loFunc functions take a void pointer, which, when the functions are called, will be pointing to the customData initialized by the initFunc.</p>

<h3>Using End-Functions</h3>
<p>An end-function is another function you supply, like the hiFunc and loFunc functions. The end-Function is called only at the end of a task. This is most useful for a train where you want to change some aspect of the train at the end of each train, but not after every pulse in the train. The end function is passed a pointer to the entire taskParams structure, not just your custom data:
<dl>
	<dt>setEndFunc (void (*endFunc)(taskParams *))</dt>
	<dd>Sets the endFunc pointer in taskParams structure to address of your function<dd>
	<dt>unSetEndFunc (void)</dt>
	<dd>Sets the endFunc pointer in taskData structure to nullptr</dd>
	<dt>hasEndFunc (void</dt>
	<dd>returns 1 if an endFunc is currently installed, else 0 if endFunc pointer in taskData structure is NULL</dd>
</dl></p>


<h3>Modifying Custom Data</h3>
<p>After creating a pulsedThread, you may wish to change the custom data referenced by the taskData pointer or the endFuncData pointer in the taskParams struct. That data is not something we want to be easily modified, because it is shared between the pulsedThread object and its pthread. The modCustom function can be used with the isLocking parameter to modify taskData in a thread-safe way. You pass modCustom a pointer to your data modification function (modFunc) and a pointer to the data for your modfunc to use. If isLocking is set, modCustom copies the data and function pointers into the taskParams structure and sets a flag to alert the pthread. The pthread will run the modfunc when it is not actively doing a task. This way, data will not be changed in the middle of a pulse or train. When the pthread has run the modfunc, it resets the flag. The getModCustomStatus function can be used to see if your modfunc has run. Do not delete the modData that you passed to modCustom until the function has run. You can get a pointer to your customData in taskData with getCustomData, through which you can read and even modify the taskData directly. You can also use this pointer to delete your custom data just before you kill the thread. A better method is to supply a function to delete your custom data, and then the pulsedThread destructor will run your delCustomData function (with a pointer to your custom data) in its own destructor. Functions for modifying custom data:</p>
<dl>
<dt>int modCustom (int (*modFunc)(void *, taskParams *), void * modData, int isLocking)</dt>
<dd>- modifies taskData or endFuncData using your provided modFunc and pointer to your modification data, with thread-safe locking option. The parameters are:
	<dl>
		<dt>int (*modFunc)(void *, taskParams * )</dt><dd>- a pointer to a function that takes 2 parameters,
			<ol><li>a pointer to your input data</li>
			<li>a pointer to the taskParams structure</li>
			</ol></dd>
	<dt>void * modData</dt>
	<dd>- a pointer to whatever data you want the modFunc to use</dd>
	<dt>int isLocking</dt><dd>- flag to indicate if you want to wait for pthread to finish a task. You can set this to 0 IF you are absolutely sure the pthread will not be accessing the custom data</dd></dl></dd>
<dt>int getModCustomStatus (void)</dt><dd>- Returns 1 if the pulsedThread object is waiting for the pThread to run the modData function, else 0</dd>
<dt>void * getCustomData (void)</dt><dd>- Returns the pulsedThread's taskData pointer. Can be used to read or write the taskData. Be careful.</dd>
<dt>void setCustomDataDelFunc (void(*delFunc)(void * volatile))</dt><dd> - saves a pointer to the passed in function that will be called to delete your custom data when the pulsedThread is killed</dd></dl>



<h3>Installing the pulsedThread Library</h3>
Making the C++ library is done with the provided make file
<dl>
	<dt>make</dt>
	<dd>compiles the library</dd>
	<dt>sudo make install</dt>
	<dd>copies the compiled library to usual places and also the header files to the usual place.</dd>
	<td>make greeter</td>
	<dd>compiles the Greeter application, by running the compiler command: g++ -O3 -std=gnu++11 -lpulsedThread Greeter.cpp -o Greeter</dd>
	<td>make minimalGreeter</td>
	<dd>compiles the MinimalGreeter application, by running the compiler command: g++ -O3 -std=gnu++11 -lpulsedThread minimalGreeter.cpp -o MinimalGreeter</dd>
</dl>
Make sure to run make install before running make greeter or make minimalGreeter.

<h3>A Minimal Application Example</h3>
<p>The file Greeter.cpp contains code for a small test application that demonstrates making and using a pulsedThread object with hiFunc and lowFunc that simply print some information. Aside from main, Greeter.cpp contains the HI, LO, and INIT functions, and the definition of a structure to hold the custom data:</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pulsedThread.h&gt;
#include "Greeter.h"

/*************************************Initialization function*******************************************************
This function initializes the custom data the pthread will need. Previously, we made and filled a ptTestStruct
structure initDataP and passed it to the pulsedThread construtor  (in main).
Here we make an initialization */
int ptTest_Init (void * initDataP, void * &amp;taskDataP){

	// initDataP is a pointer to our custom data structure, so cast it to that
	ptTestStructPtr initData = (ptTestStructPtr) initDataP;
	// task data pointer is a void pointer that points to the taskCustomData field in the taskParams struct
	// It needs to be initialized to a pointer to ptTestStruct 
	taskDataP = new ptTestStruct;
	// make a local ptTestStructPtr  so we don't have to keep casting taskDataP each time we use it
	ptTestStructPtr taskCustomData  =(ptTestStructPtr) taskDataP;
	// copy over name from initialization struct
	int iPos;
	for (iPos=0; iPos &lt; 255 &amp;&amp; initData->name[iPos] != 0; iPos+=1){
		taskCustomData->name[iPos] = initData->name[iPos] ;
	}
	taskCustomData->name[iPos] =0;
	// set times to 0  at start
	taskCustomData->times = 0;
	return 0;
}

/****************************************High and Low functions*********************************************************/
void ptTest_Hi (void * taskData){
// cast task data to our custom struct
	ptTestStructPtr ourData = (ptTestStructPtr) taskData;
	// Print
	if (ourData->times ==0){
		printf ("Hello  from %s\n",  ourData->name);
	}else{
		printf ("Hello again for the %dth time from %s\n",  ourData->times + 1, ourData->name);
	}
}

void ptTest_Lo (void * taskDataP){
	// cast task data to our custom struct
	ptTestStructPtr ourData = (ptTestStructPtr) taskDataP;
	// Print
	if (ourData->times ==0){
		printf ("goodbye  from %s\n",  ourData->name);
	}else{
		printf ("goodbye again for the %dth time from %s\n", ourData->times + 1, ourData->name);
	}
	// only for the low, increment times
	ourData->times +=1;
}

// main function makes a pulsedThread to say hello and goodbye.
int main(int argc, char **argv){
	// make a ptTestStruct to use for iniitialization
	ptTestStruct initStruct;
	initStruct.name [0] = 'P';
	initStruct.name [1] = 'u';
	initStruct.name [2] = 'l';
	initStruct.name [3] = 's';
	initStruct.name [4] = 'e';
	initStruct.name [5] = 'd';
	initStruct.name [6] = ' ';
	initStruct.name [7] = 'T';
	initStruct.name [8] = 'h';
	initStruct.name [9] = 'r';
	initStruct.name [10] = 'e';
	initStruct.name [11] = 'a';
	initStruct.name [12] = 'd';
	initStruct.name [13] = 0;
	// make a pulsedThread with our pttestStruct and our Hi and Lo functions. USe microsecond ddelay, microsecond duration, and number of pulses method
	int errVar;
	pulsedThread * train1 = new pulsedThread ((unsigned int)50000, (unsigned int)50000, (unsigned int)10, (void *) &initStruct, &ptTest_Init, &ptTest_Lo, &ptTest_Hi, ACC_MODE_SLEEPS, errVar);
	if (errVar){
		printf ("Failed to make pulsed thread.\n");
		return 0;
	}
	// let's make another train ,running half the speed of the first one, with a different name 
	// because we copy the array into the custom data sruct, and not just pass a pointer to the array, we can reuse the same array to make second pulsedThread
	initStruct.name [13] = ' ';
	initStruct.name [14] = 'n';
	initStruct.name [15] = 'u';
	initStruct.name [16] = 'm';
	initStruct.name [17] = 'b';
	initStruct.name [18] = 'e';
	initStruct.name [19] = 'r';
	initStruct.name [20] = ' ';
	initStruct.name [21] = 't';
	initStruct.name [22] = 'w';
	initStruct.name [23] = 'o';
	initStruct.name [24] = 0;
	pulsedThread * train2 = new pulsedThread ((unsigned int)100000, (unsigned int)100000, (unsigned int)5, (void *) &initStruct, &ptTest_Init, &ptTest_Lo, &ptTest_Hi, ACC_MODE_SLEEPS, errVar);
	if (errVar){
		printf ("Failed to make second pulsed thread.\n");
		return 0;
	}
	train1->DoTask ();// a train of 10 times should be enough, so just do it once
	train2->DoTask ();
	// show that the train is running on its own
	printf ("Trains were started and should be printing in a second\n");
	// a loop to show we can do real work in the main thread while the pulsedThreads do their own things.
	double aNum=0;
	while (train1->isBusy() &amp;&amp; train2->isBusy()){
		for (float i=0;i &lt; 100000; i+=1){
			aNum += (i*i)/(i+1);
		}
		printf ("Value of busy-work variable calculated to be %.12f\n", aNum);
	}
	printf ("Threads are done printing and so am I\n");
	return 0;
}
</pre>

<p>the main function first makes a ptTestStruct to use for initialization. It is defined in Greeter.h:
<pre>
typedef struct ptTestStruct{
	char name [256];	// name to add to message to print 
	int times;			// track number of times we we have printed it (not used for INIT, only for HI,LO funcs)
}ptTestStruct, *ptTestStructPtr;
</pre>
The ptTestStruct has two fields: a character array to hold the name part of the message to print, and an integer that we use to track the number of times a message is printed. We use the same structure type for initialization of the custom data as we will use for the custom data itself, but that is not generally the case.</p>

<p>Main then calls the pulsedThread constructor with the addresses of the ptTestStruct we just made, and the addresses  of our Hi, Lo, and Init functions, plus timing information on the duration and delay of each pulse (0.5 seconds each), and the number of pulses (a train of 10). Note that we use the integer microsecond delay, microsecond duration, and number of pulses version of the constructor. Also passed to the constructor are a value for pulse timing mode and a pass-by-reference errVar will be set to a non-zero value if the pulsedThread can not be created. The pThread constructor makes a taskParams struct. The constructor calls our INIT function, ptTest_Init, with the pointer to the pttestStruct we passed it, plus a a pointer to the taskCustomData field in the taskParams struct. ptTest_Init initializes the taskCustomData pointer to a new ptTestStruct, initializes the times field of the new pttestStruct to 0, and and copies over the name field from the initialization struct. Finally, the constructor will create the pthread and start the pthread function running, waiting for tasks to be requested.</p>

<p>Main then makes another pulsedThread, requesting another train running half the speed of the first one, and with a different name. Both threads are configured to output a train. Each pulsedThread object sets the doTask variable in its taskParams struct to 1 to signal its pthread to do the train once. The pthread times the pulses and calls the HI and LO functions as appropriate. The HI and LO functions are called with a void pointer to the customData made by the initialization function. The HI and LO functions cast the pointer to a ptTestStructPtr and print a message that contains the name from the character array in the ptTestStruct. The LO function also increments the count in the times field.</p>

<p>After the pulsedThreads are started,  main runs a loop that does some arbitrary calculation and periodically prints the results to show that we can do real work in the main thread while the pthreads run independently. From the loop, we call the isBusy method so we can exit the loop and the program when both pulsedThreads have finished their task.

<h3>An Even More Minimal Application Example</h3>
The file minimalGreeter.cpp shows the bare minimum of functions needed to use the pulsedThread library, containing a main function that makes a pulsedThread and runs it, a hiFunc, but no loFunc, no initFunc, and no definition of a customData structure.
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pulsedThread.h&gt;

/****************************************High function*********************************************************/
void ptTest_Hi (void * taskData){
	// cast task data to a character array.
	char* name = (char *) taskData;
	// Print hello 
	printf ("Hello  from %s\n",  name);
}

// makes a very minimal pulsedThread to say hello, with no lowFunc, no initFunc, and customData as a simple array, not a structure
int main(int argc, char **argv){
	// make a ptTestStruct to use for initialization
	char name [13];
	name [0] = 'P';
	name [1] = 'u';
	name [2] = 'l';
	name [3] = 's';
	name [4] = 'e';
	name [5] = 'd';
	name [6] = ' ';
	name [7] = 'T';
	name [8] = 'h';
	name [9] = 'r';
	name [10] = 'e';
	name [11] = 'a';
	name [12] = 'd';
	name [13] = 0;
	// make a pulsedThread with our Hi function but no lo func. Value for low time needs to be 0 for this. Use microsecond delay, microsecond duration, and number of pulses method
	int errVar;
	pulsedThread * train1 = new pulsedThread ((unsigned int)0, (unsigned int)5E5, (unsigned int)10, (void *) &amp;name, nullptr, nullptr, &amp;ptTest_Hi, ACC_MODE_SLEEPS, errVar);
	if (errVar){
		printf ("Failed to make pulsed thread.\n");
		return 1;
	}
	// ask the pthread to do a train
	train1->DoTask ();// a train of 10 times should be enough, so just do it once
	// show that the train is running on its own
	printf ("Train was started and should be printing in a second\n");
	// a loop to show we can do real work in the main thread while the pulsedThreads do their own things.
	double aNum=0;
	while (train1->isBusy()){
		for (float i=0;i&lt;100000;i+=1){
			aNum += (i*i)/(i+1);
		}
		printf ("Value of busy-work variable calculated to be %.12f\n", aNum);
	}
	printf ("Thread is done printing and so am I\n");
	return 0;
}
</pre>


10) Using pulsedThread in a Python C++ Module

To use the pulsedThread C++ library in a Python module, you can start with the wrapper functions provided in the file pyPulsedThread.h. These functions are designed to work with a pulsedThread object on the C++ side of things and a PyCapsule object containing a pointer to that pulsedThread object on the Python side of things. For general information on writing Python C modules, see the Python/C API Reference Manual at https://docs.python.org/3.4/c-api/index.html.

As when using pulsedThread directly from C++, you must supply at minimum the C++ functions for initialization of the taskCustom data, and HI and LO event functions. You must also supply a Python C++ module function that makes a new pulsedThread using your initialization and HI and LO functions. This function must return to Python a PyCapsule that wraps a pointer to your pulsedThread object. From Python, you pass that PyCapsule as a parameter to functions from pyPulsedThread.h that interact with the pulsedThread object, asking it to do tasks and configure pulse/train timing.

Wrappers for almost all of the pulsedThread library control functions and setters and getters are provided. They are called from Python as follows:

isBusy (PyCapsule pulsedThreadPtr) - Returns number of tasks a pthread has left to do, 0 means finished all tasks

waitOnBusy (PyCapsule pulsedThreadPtr, float timeOut) - Returns when a pthread is no longer busy, or after timeOut secs

doTask (PyCapsule pulsedThreadPtr) - Tells the pulsedThread object to do whatever pulse or train it was configured for

doTasks (PyCapsule pulsedThreadPtr, int numTasks) - Tells the pulsedThread object to do whatever pulse or train it was configured for numTasks times without stopping in between.

startTrain (PyCapsule pulsedThreadPtr) - Tells a pulsedThread object configured as an infinite train to start

stopTrain (PyCapsule pulsedThreadPtr) - Tells a pulsedThread object configured as an infinite train to stop

modDelay (PyCapsule pulsedThreadPtr, int delay) - sets the delay period of a pulse or LOW period of a train

modDur (PyCapsule pulsedThreadPtr, int delay) - changes the duration period of a pulse or HIGH period of a train

modTrainLength (PyCapsule pulsedThreadPtr, int length) - changes the number of pulses of a train

modTrainDur (PyCapsule pulsedThreadPtr, float time) - changes the total time duration of a train bychanging number of pulses

modTrainFreq (PyCapsule pulsedThreadPtr, float freq) - changes the frequency of a train preserving duty cycle and time duration

modTrainDuty (PyCapsule pulsedThreadPtr, float duty) - changes the duty cycle of a train

getPulseDelay (PyCapsule pulsedThreadPtr) - returns pulse delay, LO time of a train, in seconds

getPulseDuration (PyCapsule pulsedThreadPtr) - returns pulse duration, HI time of a train, in seconds

getPulseNumber (PyCapsule pulsedThreadPtr) - returns number of pulses in a train, 1 for a single pulse, or 0 for an infinite train

getTrainDuration (PyCapsule pulsedThreadPtr) - returns time duration of a train, in seconds

getTrainFrequency (PyCapsule pulsedThreadPtr) - returns frequency of a train, in Hz

getTrainDutyCycle (PyCapsule pulsedThreadPtr) - returns duty cycle of a train, ratio of HI time to (HI + LO time),between 0 and 1

unsetEndFunc (PyCapsule pulsedThreadPtr) - un-sets any end function set for this pulsed thread. Each module must provide its own function for setting an end function.

hasEndFunc (PyCapsule pulsedThreadPtr) Returns the endFunc status (1=installed or 0=not installed) for a pulsed thread

11) Sample Python C++ Module Example

The file pyGreeter.cpp makes a simple Python C++ module using pyPulsedThread.h. pyGreeter.cpp provides a single function that makes a pulsedThread object and returns a pyCapsule containing a pointer to it.

pulsed_C_Greeter (PyObject *self, PyObject *args);
The parameters passed to this function from Python are a string for a name, and an integer for timing mode. The C module interface passes them to C++ as a pointer to a python object, PyObject *args, and the C module interface function PyArg_ParseTuple is used to parse it into a string and an integer.

const char * localName;
int accLevel;
PyArg_ParseTuple(args,"is",  &amp;accLevel, &amp;localName));
pulsed_C_Greeter makes a new pulsedThread object using the same init, hi, and lo functions, ptTest_Init, ptTest_Hi, and ptTest_Lo, that was used in Greeter.cpp, by #including the Greeter.h header file. pulsed_C_Greeter uses the microsecond delay, microsecond duration, and number of pulses method:

pulsedThread * threadObj = new pulsedThread ((unsigned int)50000, (unsigned int)50000, (unsigned int)10, (void * volatile) &initStruct, &ptTest_Init, &ptTest_Lo, &ptTest_Hi, accLevel, errCode)

Note that printing from the C++ side of things, as done by pt_Test_Hi and ptTest_Lo, means that printed messages appear in the terminal window. This is seamless if launching Python from the terminal. If using an environment like IDlE, launch it from a terminal window, not from the menu, with: idle3 & Then the messages from the C++ module will appear in the terminal window from which IDlE was launched.

Finally, pulsed_C_Greeter returns to Python a PyCapsule wrapping the pulsedThread object:

return PyCapsule_New (static_cast <void *>(threadObj), "pulsedThread", pulsedThread_del);
You can build the module ptGreeter with the provided Python setup script.

python3 setup_ptGreeter.py build_ext --inplace

Use "build_ext --inplace" instead of "install" to install it in the local folder so you can easily delete it after building it and running it, as it is not useful enough to be a permanently installed library.

The Python code in PTGreeter.py demonstrates making a wrapper providing a "Pythonic" interface, the class PT_Greeter, for an external module based on the C++ pulsedThread library, in this case ptGreeter. A PTGreeter object contains a field, task_ptr, for a PyCapsule object containing a pointer to a pulsedThread object on the C++ side. The main function works similarly to that of the C++ program described in Greeter.cpp. It makes two pulsedThreads that print greetings, and sets them running at the same time. Then it starts doing calculations and printing results in a loop.

12) ptPyFuncs: pulsedThreads with Python Functions

ptPyFuncs is a Python C++ module that allows you to use the pulsedThread C++ library from Python for threading and timing of Python tasks without writing and compiling a dedicated Python C++ module. ptPyFuncs provides functions to initialize a pulsedThread with a Python object that has HiFunc, LoFunc, and (possibly) endFunc methods.

ptPyFuncs.initByPulse (Python object, int lowTicks, int highTicks,int nPulses, int ACClevel)
ptPyFuncs.initByFreq (Python object, frequency, duty Cycle, float train duration, accuracy_level)
In both cases, the first argument is a Python object that MUST have methods named exactly "HiFunc" and "LoFunc" that don't take extra parameters other than self. The other parameters for initialization are for pthread timing which is done as usual in C++ as described earlier. Now, however, the high, low and end functions are callbacks to the Python object's HiFunc, LoFunc, and EndFunc, and thus run in Python with full access to the Python environment. Yes, with some care, a Python C module can call Python functions, even from separate C threads. The Python interpreter runs only one thread at a time and uses a Global Interpreter Lock (GIL) to arbitrate which thread is currently running. The code in ptPyFuncs uses Python/C API functions PyGILState_Ensure to get the lock before calling any Python functions and PyGILState_Release to release the lock when finished. It is possible to end up in a deadlock if, for instance, a C module function gets the GIL and then calls a Python function that calls another C module function that also tries to get the GIL.

As described before, both init functions return a PyCapsule object wrapping the C++ pulsedThread object, allowing it to be controlled with the entire set of functions from pyPulsedThread.h. Setting timing and requesting tasks functions as before.

You can change the Python object whose functions the pulsedThread C++ object calls with:

ptPyFuncs.setTaskObject(PyCapsule, Python Object)
The first argument is the Python pyCapsule that points to the pulsedThread, and the second argument is a Python object providing the HI and LO functions, as described previously.

You can set an endFunction from a Python object, which can be the same object as used for the task, with:

ptPyFuncs.setEndFunctionObject(PyCapsule, Python Object, functionParamType)
The Python Object must have a method named exactly "EndFunc" that gets passed 4 parameters describing pulse number and timing. If functionParamType is 0, the endFunc is called with with microseond pulse delay, duration, and number of pulses as the first three parameters. If functionParamType is non-zero, the endFunc is called with train frequency, duty cycle, and train length. In either case, the 4th parameter is the number of tasks left to be done.

You can install the ptPyFuncs module from a terminal with:

sudo python3 setup_pyPTpyFuncs.py install
PT_Py_Greeter is a Python class that uses ptPyFuncs to, what else, print hellos and goodbyes. Only now, printing is done within the Python environment by Python objects.

The PT_Py_Greeter class field task_ptr is a pyCapsule that points to a pulsedThread object on the C++ side of things. All the calls to the C++ code is through an object's task_ptr, which is created in the PT_Py_Greeter init method.

The main function makes a PT_Py_Greeter and sets it going, then does some calculations in a loop, printing results as it goes, to show the independence of the threaded PT_Py_Greeter from the main code.The class field PSEUDO_MUTEX is used for preventing print statements from different places in the code from executing at the same time, which would lead to garbled output. Unlike a real mutex, execution is not halted while waiting on the PSEUDO_MUTEX, hence the loops with calls to sleep to allow the other threads of execution to continue while waitng for the PSEUDO_MUTEX to be free. Also, read/write to the PSEUDO_MUTEX is not atomic; one thread may read PSEUDO_MUTEX as 0, and set it to 1, but in the very brief interval between reading and writing to PSEUDO_MUTEX, another thread may have read PSEUDO_MUTEX as 0 and so both threads would think they have the mutex.




<h2>taskParams Structure</h2>
The fields of the taskParams structure are:

<h3>int accLevel</h3><p>This value sets the method that the pthread uses to control pulse timing. Threads can: 0) sleep for pulse duration/delay, 1) sleep for most of the delay duration, waking up and looping for the last few hundred microseconds (controlled by constant kSLEEPTURNAROUND), or 2) re-calculate sleep time for each duration/delay, and completely countermand sleeping if pthread is running late.</p>

<h3>unsigned int doTask</h3>
The lower 29 bits of this 32 bit unsigned integer are used for setting/tracking number of tasks requested/left to do. Changes to this variable are made after calling pthread_mutex_lock, and the pthread is signalled that a change has been made with pthread_cond_signal. The pthread sleeps when doTask is zero, and wakes when doTask is non zero. For a finite length train or a pulse task, the pthread starts doing its task, decrementing doTask as it completes each task (single pulse or train), and sleeps again when doTask gets to 0. For an infinite train, the pthread starts when doTask =1 and stops the train when doTask = 0, but as it only reads and never writes to doTask, locking the mutex is not required.

<p>The upper 3 bits of doTask are reserved for alerting the pthread that pulse delay, pulse duration, or custom thread data have been changed:
<table cellspacing="0" cellpadding="0" border = "1">
	<caption>doTask Signal Bits</caption>
<tbody>
	<tr>
		<td>Constant</td>
		<td>Value</td>
		<td>Bit</td>
		<td>Meaning</td>
	</tr>
	<tr>
		<td>const unsigned int kMODDELAY</td>
		<td>536870912</td>
		<td>2<sup>29</sup></td>
		<td>set when pulse delay is changed</td>
	</tr>
	<tr>
		<td>const unsigned int kMODDUR</td> 
		<td>1073741824</td>
		<td>2<sup>30</sup></td>
		<td>set when pulse duration is changed</td>
	<tr>
		<td>const unsigned int kMODCUSTOM</td>
		<td>2147483648</td>
		<td>2<sup>31</sup></td>
		<td>set when task custom data is changed</td>
	</tr>
</tbody>
</table>
Setting any of these these bits from the pulsedThread object causes the pthread to be awakened and it will change timers for delay/duration or call the custom task modification function. The pthread will then unset the signal bits.</p>

<h3>Pulse Description</h3>
The timing of pulses is stored in two complementary ways, one based on delay and duration times, and the other on frequency and duty cycle.  
<table cellspacing="0" cellpadding="0" border = "1">
	<caption>Pulse Description (time based)</caption>
	<tbody>
	<tr>
		<td><B>unsigned int pulseDelayUsecs</B></td>
		<td>The duration of "low" time in microseconds, >=0. For a train or infinite train,(but not for a single pulse), setting pulseDelayUsecs = 0 means the loFunc is never called.</td>
	</tr>
	<tr>
		<td><B>unsigned int pulseDurUsecs</B></td>
		<td>The duration of "high" time in microseconds, must be > 0. If your task is periodic, but not a pulse with defined "high" and "low", set pulseDelayUsecs to 0 and control timing with pulseDurUsecs only</td>
</tr>
<tr>
<td><B>unsigned int nPulses</B></td>
<td>The number of pulses in a train. Can be 0 for an infinite train, 1 for a single pulse, >=2 for a train of defined length.</td>
</tr>
</tbody>
</table>
<br>
<table cellspacing="0" cellpadding="0" border = "1">
	<caption>Train Description (Frequency Based)</caption>
	<tbody>
		<tr>
			<td><B>float trainDuration</B></td>
			<td>The duration of the train, in seconds, or 0 for an infinite train</td>
		</tr>
		<tr>
			<td><B>float trainFrequency</B></td>
			<td>The frequency in Hz, i.e., pulses/second</td>
		</tr>
		<tr>
			<td><B>float trainDutyCycle</B></td>
			<td>Duty Cycle = PulseDurUsecs/(pulseDurUsecs + pulseDelayUsecs), 0 &lt; Duty Cycle &lt;1</td>
		</tr>
	</tbody>
</table>
This duplication is for the benefit of functions that, for example, change train frequency without changing train duration by modifying the number of pulses. Frequency-based description is not well suited for describing single pulses. Pulse timing by the pthread always uses the time based microseconds, with nanosleep function.

<h3>void (*hiFunc)(void *) and void (*loFunc)(void *)</h3>
hiFunc and loFunc are pointers to the custom functions that run at the start of the duration (High Function) and delay (Low Function) periods of a pulse. The user needs to provide these functions when creating a new pulsedThread object. They each get a void pointer to custom taskData, which they can recast to the correct type to operate on.  The execution time of hiFunc and loFunc need to be short relative to pulse delay/duration.

<h3>void * taskData</h3>
taskData is a pointer to data customized for the thread's main task, running hiFunc and loFunc.  Any needed data other than pulse timing and number are accessed with this pointer.  It needs to be initialized when the pthread is started, with anything from a single value to a large structure, depending on what the task of the pthread needs. The hiFunc and loFunc are both passed this pointer.  Remember that the pulsedThread object can access this data as well, so it can be used to return data as well as to signal a thread. If the pulsedThread object writes to the parts of taskData used by the pulsedThreadFunc function, you may wish to use the mutex for protection.

<h3>void * endFuncData</h3>
Pointer to optional function that can be set to run at the end of every task. Thus, it would run at the end of a train (nPulses &gt2;= 2), or at the end of each pulse for an infinite train or single pulse. The task structure includes a pointer specifically for data used by an endFunction, but the endFunction gets the pointer to the whole task structure, so it may be used, e.g, to change task timing.

<h3>void (*endFunc)(void *, taskParams *)</h3>
An end Function is a function pointer to an optional user-provided function that runs at the end of each train for tasks configured as finite length trains, or at the end of each pulse for tasks configured as a single pulse or an infinite train.  An endFunc gets a void pointer to the endFunc data, plus a pointer to the whole taskParams structure, to make it easy for an endFunc to modify pulse timing or number.  If the user does not provide an endFunc, the pointer for endFunc will be NULL, and no endFunc will be run by pulsedThreadFunc.

<h3>void * endFuncData</h3>
endFuncData is a pointer specially reserved for data customized for an End Function, if one is installed. This pointer is separate from the taskData pointer so that handling of End Functions and associated data can be independent of hiFunc and loFunc task data.  That is, you can have an endFunc that is task agnostic, and you can install and un-install End Functions without affecting the main task.

<h3>int (*modCustomFunc)(void *, taskParams *)</h3>
modCustomFunc is a pointer to a user-provided function that is run by pulsedThreadFunc when kMODCUSTOM is set in doTask. This provides a thread-safe way to modify the task data or endFunc data, as pulsedThreadFunc will wait until a pulse ot train is completed before running the modCustomFunc. The modCustomFunc gets a pointer to modCustomData and a pointer to taskParams.

<h3>void * modCustomData</h3>
modCustomData is pointer to the data to be used by a modCustomFunc to modify the task data or endFunc data. It needs to be initialized before modCustomFunc is called.

<h3>pthread_t taskThread, pthread_mutex_t taskMutex, and pthread_cond_t taskVar</h3>
These are data structures provided by pthread.h.  taskThread is a pthread structure, initialized when the pthread is created, and freed in the pulsedThread destructor.  taskMutex is a mutex that is used in the lock and unlock operations to prevent simultaneous writing by the pthread and the pulsedThread object to doTask or perhaps taskData or endFuncData.  taskVar is a conditon variable used to signal from a pulsedThread object to the associate pthread that doTask has been modified and there is work to do.  The pthread uses the pthread_cond_wait function to sleep until a task has been called, then does the task(s)and sleeps again.

</body>
</html>